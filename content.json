[{"title":"为什么每个人都应该学点计算机","date":"2017-03-30T08:19:17.000Z","path":"2017/03/30/为什么每个人都改学点计算机/","text":"我总是有一种冲动，就是向每人认识的人强调计算机的重要性。这并非是我一个 IT 男的自卖自夸，而是从心底真正认识到了计算机的重要性。而且这种意识随着自己对计算机了解的逐步深入，越来越强。 为什么每个人都应该学点计算机？从最根本的点出发，我们为什么要学习？爱学习和不爱学习的人到底有什么差别？我觉得最根本的差别就在于生活的质量。我们不去讲什么为中华之崛起而学习的大道理，我们大多数从小到大读书学习的目的不就是为了提高自己能力，能拥有更高质量的生活吗？ 然后再从怎样拥有高质量的生活出发。现代社会是一个分工协作明确的社会，你所谓的高质量生活必然来自于你能力的稀缺性得到社会的认可，然后在这个社会上贡献价值，获取回报。那我们关注的点也就转移到了一个人的能力上。事情似乎变得简单起来，我们只要提高自己的能力，就能挣得丰厚的报酬，然后成为高富帅，赢取白富美，走上人生巅峰。然后闹铃响了，该起床了。 这是一个太常见的例子，遇到难题了一通分析，然后告诉自己我要学习，我要变强，我要挣钱。然后闹铃又响了，嗯，老子还是觉得睡个懒觉更舒服，关掉闹铃，继续做梦。事后不忘总结一下，道理我都懂，我行动力薄弱。看到这些文章，暗道，哇靠，扎心了老铁！这大概是太多太多人的常态。 回到刚才的话题，什么才算是有能力呢？而为什么提高能力需要学习计算机的知识呢？每个人都有能力，吃饭，听，看，读写，这些都算能力。我们在这不谈这些，因为这些能力几本和别人无关。这里要说的是为社会创造价值的，能拿来工作的能力。在经济学上，自然稀缺性很大程度上决定了一个事物的价值，能力也基本上是这个道理，你拥有的能力越少人拥有，你的能力就越有价值。那拥有能力和学计算机有什么关系呢？ 其实这个问题很好回答。人和动物的差别，人和人的差别最大的地方在哪？在学习能力，在大脑里的知识。这些知识当然不会是天生的，也都是学习而来。然后再想一个问题，为什么好多人幻想穿越回古代，自己能怎么着怎么着，然后开始幻想，而在现代社会就是不能怎么样呢。其实这个幻想是有一个根据的，穿越回古代所呈现的各种威能无非是利用古代不知道的知识罢了。为什么会这样？为什么现代随随便便一个初中生都能在科学知识上秒杀古代的秀才举人？要知道古代的秀才和举人可是要十年，二十年寒窗，比现在很多学生刻苦的多。 这是一个特别有趣的问题，要知道古代人和现代人大脑结构上几乎是一样的，生物进化是一个极其缓慢的过程，几千年的时间，不足以在人类大脑上造成什么变化。那为什么现代人和古代人知识总量上的差别大如天堑鸿沟呢？其实这里面最大的差别只有一个，就是信息传递的方式和速率。如果你不信服我的观点，请先忍住，不要拍砖。我们来探讨一些常识，中国古代四大发明：造纸术，指南针，活字印刷术，火药。我们看其中两项，造纸术和活字印刷术。造纸和活字印刷术被列为四大发明的意义全在于信息传递方式和速率的改变，而不是在于上厕所再也不用洗手。 造纸术的改良让造纸变得简单和低成本，然后前人的智慧得以更好的流传，现世的智慧得到更好的交流和碰撞。活字印刷更是加速了这种信息流通的速率。而这些还远远不够，然后人类发明了计算机。发明了计算机网络，计算机硬件的发明就像是造纸术（不止于此），改变了信息存储和处理的方式，而计算机网络就是活字印刷术的发明，大大提高了信息传递的速率。如果你不认识字，那对你来说纸的发明就毫无意义，因为这些文字表达的知识和信息不能快速的流入你的大脑里。 所以我们学习最先学习的是识字。学会了识字你才能更快的吸收以文字为载体的知识，进而才有转化为个人能力的可能。到此我想计算机学习的意义也就不言自明了。我们学习计算机，实际上就是在用最快的获取知识的方式来充实自己，提高自己。我不愿把工作和生活比作战场，但是如果真要比的话，用计算机机获取知识的和仅靠书本获取知识的，甚至是不学习的人的对比，就是热兵器、冷兵器和小木棍的对比。 这里讲的计算机，并不是台式机或者笔记本电脑。这里讲的学习计算机，也非组装计算机或 PPT 的制作之类的知识，当然这些是应当有所了解的。我这里说的计算机是指：计算机原理、电子信息技术、通信技术的最基本的原理。比如点击鼠标或敲击键盘计算机里到底发生了什么；发一封邮件是怎样被接收到的；搜索引擎又是怎样的查到信息返回的，电话和短信又是怎样传输的；甚至美图秀秀到底是如何把你的照片 P 的美美的。计算机怎样用 0 和 1 这样的信号最终表达出整个世界的。这些知识或许不能给你带来直接的价值，但是它能使你理解这个世界，因为现在的世界里充满了电子设备，如果你不知道电子设备是怎么工作的，那你慢慢的将对这个世界一无所知。慢慢变成一个生活在现代社会的古代人。而以计算机的发展速度，这个 “慢慢” 或许比你想象中来的要快的多。 其实我上面说的计算机的学习并不是要求每个人都去深入的了解计算机的知识。大多数领域浅尝辄止就可以了，也就是学习上的 “二八” 原则。用 20% 的时间去学一个领域 80% 的领域，然后再转到下一个领域。就像我们学汉字，没必要每个字都认识，只要把一些经常用的字认识就够了。当然这只适用于不是在这个领域刨食的，对于自己工作，安身立命的领域，还是学的越深越好。 说了这么多，到底该如何学习计算机知识呢？这里没有 998 或者 “Blue Shit 挖掘机” 的广告，因为我自己也非计算机科班出身，在大学也磕磕绊绊走了不少弯路。这里就推荐几本了解计算机比较好的书，比如：《计算机文化》、《黑客与画家》、《编码：隐匿在计算机软硬件背后的语言》。对英语阅读能力比较自信的可以直接读英文原版，更好理解一些。 然后是三个网站：网易公开课、网易云课堂、慕课网。除了慕课网其他两个并不是只有计算机的教程，还有很多其他的不错的视频可以看。慕课网对于有兴趣学习编程的可以看一下。网易公开课什么的做的还是比较良心的，上面有完整的计算机专业课程，成体系的，每门课程都有讲，跟着学还会发证书，这种免费的重点高校的课程资源为什么要视若草芥呢？ 计算机和互联网给现代人提供了太多提高自身能力的通道，学习计算机知识能让你在运用用计算机以及智能产品的时候更得心应手，能产生更多的技术联想。当然也要切记贪多嚼不烂，凡事要慢慢积累。但是就算走马观花的看一遍，也比刷刷 XX 头条看看扶老人过马路的最新报价，刷刷微博围观下且行且出轨来的有价值吧。 计算机已经包围我们生活的方方面面，对计算机了解的重要性已经像读书写字一样了，成为了人一项基本的技能。一个男生对一个女神强硬的说，我要得到你。然后女神回答，你就算得到我的人也得不到我的心。男生，我得到你的人就够了，得到你的心又什么用。 女神，得到我的心，可以解锁更多姿势。 学点计算机知识，去给你的手机和电脑解锁更多姿势吧，同时也解锁下人生的更多姿势！","tags":[]},{"title":"浅谈Http","date":"2017-02-28T18:05:32.000Z","path":"2017/03/01/浅谈Http/","text":"在Android开发中最经常见到的与服务器交互的方式就是通过Http请求了。我还是按照自己的理解来说明Http请求究竟是个什么东西。尽量不去堆砌名词，用最简单的语言就像科普一样给描述出来。 首先，Http是一种网络协议，协议这种东西就是约定好用来通信的嘛。通信协议无非就是通信双方对信息传输的约定，比如我要传个1，给你个高电平，传个0，就给你个低电平。尽管Http是应用层协议，它也是一种信息传输的约定，无非是比着0或1的编码更抽象罢了。我们要理解Http协议，首先要明白我们能用Http协议做什么，然后是哪些东西是Http这一层做的事。其实我一直觉的真正不容易懂的是http协议这一层到底包括哪些东西，什么get，post，head方法，无非就是一个规则，当我们知道http是什么之后，这些规则都简单的一笔。。。（我只写自己的理解，语言也没那么严密，感性认知，不喜勿喷） 其实就像手机一样，我们可以用手机打电话，发短信，只要知道对方的号码，会拨号，或者编辑，然后打电话要打开拨号的软件，发短信要打开短信软件进行编辑。可以把Http协议的接口就抽象为一个手机，至于怎么发出去的，怎么听到声音的，怎么连接上的，这些不用我们管，在http这一层也无需理解。这样来看http，其实也就很简单了。既然我们用http来进行客户端和服务器的交互，就自然可以想到，我们是和服务器进行交换数据的。比如我要注册，必然要把注册的账号告诉服务器，让它存起来，它验证后觉得，符合注册要求，然后返回一个信息，说成功了，然后客户端再进行其他的操作。这样的信息交互无非就四种嘛，增删改查。 同时我们来看http协议的各种请求，最常用的就是get方法和post方法了，为什么这两个最常用？因为get是对应数据的查，C／S模式下这种查不难理解吧，比如新闻客户端，一个页面那么多条新闻肯定要从服务器查询啊。每次刷新的时候去查一下服务器，然后服务器把结果取出来呈现在客户端界面上。post就对应是改数据的方法，客户端一般采集数据，更新服务端数据就用post方法。我觉得这样讲get和post的方法比说什么带不带body，格式什么的好理解吧。自然你想嘛，如果我要查，用get方法，只要知道路径，要查的字段就可以了，我自然就可以查到了，所需要的信息比较少，所以直接把参数放在url中就足够了。要用post，改数据，总要知道你要改的字段是什么，改可能牵涉一次改多个字段，比如改一篇文章，整片替换，那我都放url不是爆炸了。。。所以post一般以表单的形式提交，所以post要放参数，有数据body也就是这个原因了。就这么简单，我不知道为什么那些讲http请求的为什么老是搬书，上来就是定义，每次学一个新东西都很费劲。我觉得有这个理解，后面每一块是干嘛的其实很好理解的。 get和post方法最大的区别也就在这儿了，get是向服务端查询数据的，post对应修改更新数据的。至于什么url长度限制，什么有没有body，这些是这种传输方式的规定而已，也就是相当于语法级别的。下面来看具体的语法层面的： 方法描述 HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。 方法 描述 get 从服务器获取指定资源，第一个参数之前有一个“?”，其他参数格式为：参数名=参数值，参数之间通过“&amp;”连接 post 修改服务器资源操作，常用来向服务器传递数据（URL指定要更改的资源的地址，body已key和value对应的形式指定要更新哪个字段，更新后的值是什么） put 向服务器写入资源的方法，让服务器用请求主体部分来创建一个用请求URL命名的新文档。（也就是body部分是资源，URL部分是资源地址，然后用这个请求在服务器上添加这个资源） delete 删除请求URL所指定的资源，（参数都放在URL中，因为是删除，所有用不着body，一个URL足够指定要删除的目标资源 一般移动开发用的着的也就这四个了，其他的不再列举，理解一个，其他的也就都理解了。 http提供这几个方法给我们用，为了灵活性考虑，这些方法必然可以有各种各样的配置来应对各种不同的需求，不然http协议早就被淘汰了。比如有人想用json字符串传递参数和返回，有人想数据压缩传输，这些自然是应该被满足的。因为是约定，你怎样传输的，数据是什么格式，肯定要有个地方来说明。 报文结构请求报文http中这些配置的说明都集中在头部，就是header，header里面包含了各种对本次http请求的配置，而一般http类的框架，多采用build模式来构建一个http请求，也正是因为http 请求的这么多配置，用build模式就比较方便，xxxBuilder.xx().xx().build。类似这种，就是一个个在配置相关的参数。其实这些配置无非是最后填在http协议的报文里面，作为一种标识，我们先来看http请求报文的结构。 请求行：请求行由方法字段、URL 字段 和HTTP 协议版本字段 3 个部分组成，他们之间使用空格隔开。 请求头部：请求头部由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔。请求头部通知服务器有关于客户端请求的信息，典型的请求头有： User-Agent：产生请求的客户端的信息，比如浏览器版本，操作系统，这个我们用不着，不用管; Date：发送请求的时间 Accept：客户端可识别的响应内容类型列表;星号 “ ” 用于按范围将类型分组，用 “ / ” 指示可接受全部类型，用“ type/ ”指示可接受 type 类型的所有子类型; Accept-Language：客户端可接受的自然语言; Accept-Encoding：客户端可接受的编码压缩格式; Accept-Charset：可接受的应答的字符集; Content-Type：传输数据的类型 Host：请求的主机名，允许多个域名同处一个IP 地址，即虚拟主机; connection：连接方式(close 或 keepalive); Cookie：存储于客户端扩展字段，向同一域名的服务端发送属于该域的cookie; 上面这些东西都是约定的东西，两边通信用的，这些我们有需要就配置，没需要就不用管。 空行：最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头，这是通信编码里常用的方法，就是一个约定，看到空行就表示请求头结束; 请求body：有些方法里有body，有些方法没有，原因就是需要不需要，仔细看都能理解; 方法 Request Has Body Response Has Body Safe GET No Yes Yes Yes PUT Yes Yes No DELETE No Yes No POST Yes Yes No 上面的表格就是http对应增删改查的四种方法是否有body，是否是数据安全的说明。（http还有其他的方法，在此不再列举，Android开发一般用不到）此处的数据安全是指是否对服务端数据有影响，不是指传输过程中的安全性。也很好理解只有get方法对应查数据不会影响原数据，属于只读操作所以get操作对数据来说是安全的。其他的增删改，都会影响，有写数据的操作，所以是对服务端数据不安全的。对于哪个请求有body，哪个没有body应该也很好理解，增和改，都要有自己的数据内容上传，此处是有body设计更合理，而删和查，只需知道具体位置，具体字段即可，所以无需再用请求body，所以设计为无请求body。 响应报文整个http请求的报文结构也就是这样了，其实响应报文和请求报文并没有太大的区别： 响应报文的第一行叫状态行，这里面最重要的也就是状态码了。比如200，404等。这个状态码标志着这次请求是一个什么样的结果，就好像打电话，有正常接通，有暂时不在服务区，有您拨打的电话已停机等，这个状态码就是这么个意思，下面是状态码的具体定义： 状态码由三位数字组成，第一位数字表示响应的类型，常用的状态码有五大类如下所示： 1xx：表示服务器已接收了客户端请求，客户端可继续发送请求; 2xx：表示服务器已成功接收到请求并进行处理; 3xx：表示服务器要求客户端重定向; 4xx：表示客户端的请求有非法内容; 5xx：表示服务器未能正常处理客户端的请求而出现意外错误; 状态码描述文本有如下取值： 200 OK： 表示客户端请求成功; 400 Bad Request： 表示客户端请求有语法错误，不能被服务器所理解; 401 Unauthonzed： 表示请求未经授权，该状态代码必须与 WWW-Authenticate 报头域一起使用; 403 Forbidden： 表示服务器收到请求，但是拒绝提供服务，通常会在响应正文中给出不提供服务的原因; 404 Not Found： 请求的资源不存在，例如，输入了错误的URL; 500 Internal Server Error： 表示服务器发生不可预期的错误，导致无法完成客户端的请求 503 Service Unavailable： 表示服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常; 剩下的部分响应报文和请求报文结构基本一样，剩下头部，和body，头部表示此次返回的一些配置，和请求配置一样，比如是否要长链接，哪种格式的数据返回等，body部分也就是数据部分就是具体返回的实际数据体了，我们发起请求想要的到的结果也就是这部分内容了。把约定的数据格式转换成我们想要的格式也就ok了，现在用的最多的也就是json转Java对象了，在AndroidStudio中又个插件JsonFormat，直接把返回的body体的Json字符串生成类，用Gson解析生成对象就可以了，非常方便，不属于本篇内容，有兴趣的可以自行google。 到此关于http的这篇博客也就结束了，我并没有写关于什么一次http的请求的整个过程，当然并不是这些不重要，而是对Android开发者来说，了解我们用http能做什么，http给我们提供了什么样的接口更重要。一般网络请求，我们都会用框架，先对http从一个协议的角度去观察，从需求到设计，我们并不太需要关心实现，当然理解底层也是很有必要的，但是第一步直接就讲什么请求过程，对Android开发并没有什么实质上的帮助，而直接看报文格式，讲明白什么是get方法，为什么它没有头部，为什么post有头部，它们的差异化表现在哪，为什么是这样，这些对我们来说更为重要。至少我们能知道有时我们为什么用get而不用post，header添加的字段到底是什么意思，这些东西才更能让人接受。（完）","tags":[]},{"title":"GC机制梳理","date":"2017-01-22T08:25:41.000Z","path":"2017/01/22/GC机制梳理/","text":"","tags":[]},{"title":"Android开发中要打交道的那些Json","date":"2017-01-22T08:24:23.000Z","path":"2017/01/22/Android开发中要打交道的那些Json/","text":"","tags":[]},{"title":"View和ViewGroup事件处理机制梳理","date":"2017-01-22T08:23:00.000Z","path":"2017/01/22/View和ViewGroup事件处理机制梳理/","text":"","tags":[]},{"title":"不开玩笑，我只想认真谈技术","date":"2017-01-22T08:21:03.000Z","path":"2017/01/22/不开玩笑，我只想认真谈技术/","text":"项目告一段落，突然放松下来，又感觉有些迷茫了。可能这就是人的通病吧，看看博客，想想明年的规划，总觉得自己没有足够的努力。不是什么鸡汤，也总觉得自己能够做到更好。 可能接触的时间不够吧，想想自己肚里的那点墨水总是发虚，一个连c++都没有敲过一行的人，底层的JNI都看不懂怎么能说自己会编程呢？虽然从职业发展角度上来说，如果你在某个小领域特别精通，可能会收获更多的财富和声望，但是总觉得这些不是自己真正想要的。打心底里还是有一种求知欲，一种从上至下贯通的求知欲，每次看到一些全栈在侃侃而谈什么逆向，Linux系统通信，这种欲望便更加难以克制，然后再懒散的等那股劲过了，告诉自己洗洗睡吧，我只是一个Android应用开发的Coder。我想弄懂这些东西，就像对我的掌纹一样了解，紧紧的握在手里，伸开能清晰的看出每一条脉络的去向。 所以我这这一口气写了多篇博客 的标题，来督促自己接下来的一段时间内要梳理和内化的一些知识点。当然这些知识都是在Android APP开发层面的。我的想法是，先把这个层面要掌握的快速的沉淀下来，然后转到下一个阵地，开始着手去code，code，code。。。 对，就是这样","tags":[]},{"title":"Handler再一次回顾（二）","date":"2016-12-19T09:38:49.000Z","path":"2016/12/19/Handler再一次回顾（二）/","text":"在Handler再一次回顾里，我主要讲到了主线程在Looper的loop里循环读取消息，然后处理消息的过程，并没有说明这个消息是怎样发送的。这一篇我准备继续顺着线程执行的顺序来一步步看，怎样从发送消息到处理一个消息，以及消息究竟是个什么东西。 在接着上一篇思路往下走之前，先说一点关于进程和APP的东西。多进程的东西在此不涉及，默认我们的APP只有一个进程，当点击APP图标，需要启动一个APP时，系统为我们用孵化出一个新进程，用来执行这个APP的代码。这个新进程里面的有个线程，就是我们的主线程，同时这个主线程和其他线程的区别就是有一个Looper和MessageQueue。简单来说就是：点击APP图标后系统为我们做的事就是孵化出一个进程，进程里有一个主线程，主线程里面有个Looper，MessageQueue，然后让执行到Looper的loop循环里。这个时候主线程就在这个loop里面跑循环，每次去取消息来处理了。 然后我们再想一个问题，既然主线程都在跑圈圈了，我们怎么让主线程去显示界面呢，Activity在哪创建呢，又是如何执行到Activity的 onCreate() 方法的呢？其实这个问题的答案很好想到，只要给主线程的MessageQueue发消息，就可以了。而系统也正是这样做的， onCreate() 是由系统给主线程发消息到主线程的MessageQueue中，当loop循环取到这个消息的时候，处理消息也就是执行 onCreate() 肚子里的代码。从loop循环里面到 onCreate() 肚子里面代码的执行过程跟上篇讲的执行Handler的 handleMesaage() 方法的是一样的。 从上一篇到现在，基本上基于事件的线程的窗口机制的模型已经说清楚了。只剩下具体每一部分的细节了，比如具体怎样发消息，发到哪，取消息，从哪取，怎样取？针对这些细节，我们再根据源码，进行细致的说明。 先不急于看源码，我们先做一件事，就是自己猜，忘掉以前对Handler的认知。猜Google是怎样实现的。因为这样我们才能了解google设计这个东西的时候究竟是怎样想的，他的代码妙在什么地方，然后才对整个知识点有更深刻的认知。先不要觉得我在瞎几把扯，我真的觉得这样的理解才是顺其自然的，真正弄懂了这个东西，而不是死记硬背，含糊不清。 现在我们有四个类，Looper，Handler，Message，MessageQueue：目前来说我们仅知道的内容就是主线程跑到Looper的 loop() 循环里面，Handler 发送消息到MessgeQueue，Looper的loop中要从MessageQueue拿出消息，然后最终在Handler的handleMessage里取处理消息。 基于上面的认知我们如果设计的话，至少要Handler在调sendMessge方法的时候应该是拿到了MessageQueue的引用，然后Looper取消息的时候肯定也要有MessageQueue的引用。message被取出来的时候调要找到handler并调用它的handleMessage方法，所以，message也应该持有Handler的引用。有了这些认知以后再去看源码就相当简单了，甚至说自己都能设计出简化版。下面顺着发消息到MessageQueue，再从MessageQueue里面取消息去处理的过程撸一遍源码： 先从new一个Handler开始，看Handler的构造方法： public Handler(Callback callback, boolean async) { if (FIND_POTENTIAL_LEAKS) { final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) { Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; + klass.getCanonicalName()); } } mLooper = Looper.myLooper(); if (mLooper == null) { throw new RuntimeException( &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;); } mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async; } public Handler(Looper looper, Callback callback, boolean async) { mLooper = looper; mQueue = looper.mQueue; mCallback = callback; mAsynchronous = async; } 在这里我只罗列了两个构造方法，其他的构造方法最终还是要调到这两个构造方法（这种写法在Android源码里随处可见，包括我们发送sendMessage和postMessage，或者延时发送消息最终都是调的同一个发送消息的方法）。从这两个方法我们可以看出Handler发送消息对MessageQueue的引用时通过： mQueue = looper.mQueue; 这就说明对MessageQueue的所有引用都在Looper中的，而整个线程的MessageQueue就是looper.mQueue。而Handler持有的是Looper的引用。无论是添加消息还是摘取消息都是拿的looper.mQueue来操作的。然后我们再去看sendMessage时添加一条消息到looper.mQueue： public boolean sendMessageAtTime(Message msg, long uptimeMillis) { MessageQueue queue = mQueue; if (queue == null) { RuntimeException e = new RuntimeException( this + &quot; sendMessageAtTime() called with no mQueue&quot;); Log.w(&quot;Looper&quot;, e.getMessage(), e); return false; } return enqueueMessage(queue, msg, uptimeMillis); } private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) { msg.target = this; if (mAsynchronous) { msg.setAsynchronous(true); } return queue.enqueueMessage(msg, uptimeMillis); } sendMessage和postRunnable有好几种方法，比如 sendMessageDelayed(Message msg, long delayMillis) 和 postDelayed(Runnable r, long delayMillis) 还有另外几个，他们最终调的都是 sendMessageAtTime(Message msg, long uptimeMillis) 其实并没有什么区别，都是在某个时刻发送一个message的方式来实现的，其中延时： sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis); 由上面的Handler的enqueueMessage方法可以看出，Handler其实只是算出在什么时候发送消息，并把它作为参数传给了messageQueue，但是并没有等待到那个时间去发送，而是立即交给了MessageQueue去处理。由此便知道MessageQueue里面要么在插入消息时有一个等待过程，要么在摘取消息时有一个等待过程，然后我们继续看源码： boolean enqueueMessage(Message msg, long when) { if (msg.target == null) { throw new IllegalArgumentException(&quot;Message must have a target.&quot;); } if (msg.isInUse()) { throw new IllegalStateException(msg + &quot; This message is already in use.&quot;); } synchronized (this) { if (mQuitting) { IllegalStateException e = new IllegalStateException( msg.target + &quot; sending message to a Handler on a dead thread&quot;); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; } msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) { // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; } else { // Inserted within the middle of the queue. Usually we don&apos;t have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) { prev = p; p = p.next; if (p == null || when &lt; p.when) { break; } if (needWake &amp;&amp; p.isAsynchronous()) { needWake = false; } } msg.next = p; // invariant: p == prev.next prev.next = msg; } // We can assume mPtr != 0 because mQuitting is false. if (needWake) { nativeWake(mPtr); } } return true; } 上面的代码也比较简单： 因为MessageQueue插入操作可能来自不同线程，所以在执行插入操作时加锁，然后从这里可以看出消息队列实际上是通过链表实现的，mMessages是当前链表的头，明白了这些之后，整个代码主要就是根据message里面的时间（也就是我们在sendMessageAtTime传进来的那个时间）来判断当前入队列的这个message应该插入到链表的哪个位置，来保证整个链表是一个按时间先后排序的链表。 现在已经执行完了 enqueueMessage(Message msg, long when) 的代码，下一步应该是摘取消息来进行处理了，上篇说过，主线程在loop里绕圈，每次都去摘取一条消息进行处理，摘取消息的代码上一篇已经贴出，在loop里面： Message msg = queue.next(); // might block 摘取消息的代码稍长，而且也有点不是很好理解，因为这里面关系到同步消息和异步消息处理机制不同的问题，需要做一些铺垫才能讲的明白。现在我们先按自己的理解继续往下走，消息队列是一个链表实现的，然后时间先后顺序已经排好了，按我们的理解应该就是每次loop的过程来取消息，拿系统当前时间和链表头部的第一条消息的时间进行对比，到第一条执行时间就让它去执行，时间不到就返回一个null。 当然这只是我们的猜想，系统的实现方式比这要复杂一点，但是也复杂不了太多，下面来看queue.next()要执行的代码； Message next() { // Return here if the message loop has already quit and been disposed. // This can happen if the application tries to restart a looper after quit // which is not supported. final long ptr = mPtr; if (ptr == 0) { return null; } int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) { if (nextPollTimeoutMillis != 0) { Binder.flushPendingCommands(); } nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) { // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) { // Stalled by a barrier. Find the next asynchronous message in the queue. do { prevMsg = msg; msg = msg.next; } while (msg != null &amp;&amp; !msg.isAsynchronous()); } if (msg != null) { if (now &lt; msg.when) { // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); } else { // Got a message. mBlocked = false; if (prevMsg != null) { prevMsg.next = msg.next; } else { mMessages = msg.next; } msg.next = null; if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg); msg.markInUse(); return msg; } } else { // No more messages. nextPollTimeoutMillis = -1; } // Process the quit message now that all pending messages have been handled. if (mQuitting) { dispose(); return null; } // If first time idle, then get the number of idlers to run. // Idle handles only run if the queue is empty or if the first message // in the queue (possibly a barrier) is due to be handled in the future. if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) { pendingIdleHandlerCount = mIdleHandlers.size(); } if (pendingIdleHandlerCount &lt;= 0) { // No idle handlers to run. Loop and wait some more. mBlocked = true; continue; } if (mPendingIdleHandlers == null) { mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; } mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); } // Run the idle handlers. // We only ever reach this code block during the first iteration. for (int i = 0; i &lt; pendingIdleHandlerCount; i++) { final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handler boolean keep = false; try { keep = idler.queueIdle(); } catch (Throwable t) { Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t); } if (!keep) { synchronized (this) { mIdleHandlers.remove(idler); } } } // Reset the idle handler count to 0 so we do not run them again. pendingIdleHandlerCount = 0; // While calling an idle handler, a new message could have been delivered // so go back and look again for a pending message without waiting. nextPollTimeoutMillis = 0; } } 和我们想的并不一样，这里面也有一个死循环来摘取下一条消息，而我们再看下loop里面取下一条消息的注释： Message msg = queue.next(); // might block 有可能阻塞？对，其实loop时从MessgeQueue里摘取下一条消息的过程并不是直接返回的，而是有可能在MessageQueue.next()里面阻塞住的，我们还是看代码：nextPollTimeoutMillis这个变量就是通过messge上携带的时间减去当前时间。然后用到这个时间的只有一个地方： nativePollOnce(ptr, nextPollTimeoutMillis); 这个方法实际上就是去调C++的代码，让当前线程等待管道阻塞一段时间，传进去的也就是阻塞时间。什么管道乱七八糟的不懂也没关系，就是让当前线程阻塞住这么长时间。至于为什么是阻塞而不是让线程空转，这里有很多考虑在里面，让我这样的小白不得感叹一句，Google的工程师真的6。在这里讲下我个人的一些理解： 我们可以从JVM假想有个cpu存在，这不难理解吧，JVM本来就是虚拟机，然后主线程如果一直空转的话，不管cpu采用哪种调度策略，主线程都有可能在这一段时间得到cpu的使用权，而它执行的代码竟然是空转，这是没必要的，反正它这段时间没有消息，主线程就是通过loop摘取消息才执行的，离下一条要执行的消息既然还有时间，那就让线程在这段时间阻塞了也无妨。 第二个就是为gc考虑了。Android最重要的就是用户体验，响应速度，而Java的gc垃圾回收刚好是和这个目标相悖，因为gc的时候要：stop the world，就是要所有的东西都停下来，gc完了你们再执行。如果一个正在打字和MM聊天的用户突然被gc卡了一下，会不会觉得很不爽（当然没那么明显，但是还是肯定要考虑gc的时间的）。而这个主线程阻塞的时间既不会影响用户交互，干嘛不用来gc呢，至于其他线程，只要不是UI线程，gc阻碍一会又有什么关系呢。所以这个时间也可以给gc来考虑要不要gc。 到此摘取消息也讲的差不多了，我们之前已经讲过了处理消息的过程，消息机制的基本功能已经讲完了。 ###TODO：不过我还是有所保留的，对同步消息和异步消息这一块还没讲，然后对IdleHandler这一块也没有讲，还有就是Looper为什么要用ThreadLocal而不是用synchronized。因为要想讲明白这些，必须一层一层的往下走，先有一个基本的框架，然后再去看同步消息和异步消息其实也就是两个不同的消息类型而已，然后再取消息的过程有一点点区别，有一个时间分割栏的概念。主要还是为了让UI更流畅的显示的，平时开发基本用不着，在读View相关的源码的时候经常碰到，先有个这个印象。Looper用ThreadLocal也是基于让主线程在loop时不必因其他线程锁住Looper而等待（如果用synchronized，当其他线程用sendMessage时要拿到从Handler到Looper再到MessageQueue的引用，这是就要对Looper进行加锁。）（本篇完，下篇待续）","tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"Handler再一次回顾","date":"2016-12-17T11:19:57.000Z","path":"2016/12/17/Handler再一次回顾/","text":"只要是做过Android开发的，想必对Handler都不陌生。在我刚工作的时候就去看过Handler的源码，但当时局限于对多线程的理解并没有那么深刻，所以对Handler的理解也就仅仅停留在表面。现在有时间重看Handler源码，猛然发现：我擦，Handler这么简单，竟然好多面试都去问，好多人都是马马虎虎，一知半解。所以我想在这篇博客里，把Handler彻底讲透了，以后妈妈再也不用担心我对Handler的理解了。 其实很多人对Handler的不理解，关键还在于对线程的不理解，所以我决定先简单说下线程的相关的知识。我在这也不能跟你胡说，在Java里一切都是对象，我们先看下Java源码里线程类的注释： /** * A {@code Thread} is a concurrent unit of execution. It has its own call stack * for methods being invoked, their arguments and local variables. Each application * has at least one thread running when it is started, the main thread, in the main * {@link ThreadGroup}. The runtime keeps its own threads in the system thread * group. * * &lt;p&gt;There are two ways to execute code in a new thread. * You can either subclass {@code Thread} and overriding its {@link #run()} method, * or construct a new {@code Thread} and pass a {@link Runnable} to the constructor. * In either case, the {@link #start()} method must be called to actually execute * the new {@code Thread}. * * &lt;p&gt;Each {@code Thread} has an integer priority that affect how the thread is * scheduled by the OS. A new thread inherits the priority of its parent. * A thread&apos;s priority can be set using the {@link #setPriority(int)} method. */ 我在这也不逐行去翻译了，英语能看懂的就看看，按我的理解就是：线程就是一个执行序，有自己的执行栈。完了，就这么多。我知道这么说对于初学者者来说，肯定会在下面骂了，妈蛋，什么是执行序啊？先别急，把刀放下，咱慢慢说。我们写代码时，这个方法，那个对象，一堆乱七八糟的东西，要执行出一个确定的结果，肯定是要一个确定的顺序。包括多线程，只要逻辑上有先后顺序的信息，也一定要保证按确定的顺序来执行。 现在来想一下我们平时听了八百遍的多线程实现方式，实现 Runnable 接口，或者 new Thread() ，一个新的线程，我们不要忘了去调它的 start() 方法。这时才真正的启动了一个线程，去执行我们写在 run() 方法里的代码。其实从Android APP开发者的角度来讲，Thread的 run()就相当于Java框架给我们的一个执行代码的入口，让CPU来执行我们的代码（这么说当然是扯淡，但是你仅从APP开发者敲代码的角度去看，把编译，链接，虚拟机，操作系统全看成透明的，也就是这么个理）。 我们只要写好自己的代码，代码放进去 run() 的肚子里，然后按下开关(执行 start() 方法)，他就一直按我们写好的顺序调下去，直到所有代码执行结束。必须明白的一点是线程就是一个执行序，在Java里，他是一个类，我们要执行的代码要放到他的 run() 的肚子里面。然后调 start() 告诉 Java虚拟机，给我开一线程的执行环境，开启后来执行我写在 run() 里的代码。 有了这个认知以后我们再来看Thread的源码： public class Thread implements Runnable 这里看到的是Thread实现了Runnable接口，接着看下Runnable接口里面都定了哪些抽象方法： public interface Runnable { /** * Starts executing the active part of the class&apos; code. This method is * called when a thread is started that has been created with a class which * implements {@code Runnable}. */ public void run(); } 整个Runnable接口就这么可怜的一个 run() 方法。继续看Thread怎么实现的 run() 方法。 Runnable target; public void run() { if (target != null) { target.run(); } } 这里可以很清楚的看出来，无论是我们继承Runnable接口，还是直接new Thread实际上是没有区别的。都是最终要把需要执行的代码放到 Thread run() 的肚子里。然后调 start() 方法 public synchronized void start() { checkNotStarted(); hasBeenStarted = true; nativeCreate(this, stackSize, daemon); } start()这里就很显了 nativeCreate() 看名字就知道是调用C或C++去创建一个线程了，而创建线程以后呢，自然去调 run() 方法肚子里我们写的代码来执行了。 这时我们已经理解了我们Java层线程的意义。至于什么去stop线程啦，设置线程优先级，让线程去sleep啦，和start（）基本一样的，是交给Java框架（这里框架这个词可能不太好理解，容易误解为J2EE的框架。其实这样说是相当于把JDK当作一种框架来看，就像Android里用的FrameWork框架。）来处理的。不是我们调了这个方法就执行的，而是我们只能通过框架给我们写好的，暴露出来的接口，去跟框架交互，至于它背后是同步，异步，或者等两秒，或者怎样搞，这些只是线程具体实现上的事，跟我们理解这个线程是一个执行序没有一毛钱的关系。如果想对线程有更深入的了解，理解线程特性，可以去看一些JVM的书（比如，深入理解Java虚拟机），里面有具体的线程特性。 到了这里发现简单说下线程，似乎说了好多，并没有收住，还将继续说下去，其实还是想尽力说的明白些，因为从个人的经验来看，对线程的理解直接决定了对Handler的理解，懂线程的根本就不会不懂Handler，懂Handler不懂线程的，绕了几圈还是会晕。而且，我以前在学习Android的时候也被好多不负责任的博客折磨的死去活来。所以我最讨厌那种上来就甩你一脸定义，代码，专有名词，乱七八糟的东西，老子懂这些的话还看你在这逼逼？ 扯远了，继续说线程，刚刚说线程就是执行序，那么主线程呢？（在Android里一般主线程，UI线程，main线程都是在说一个玩意：主线程）。主线程既然是线程，它也是一个执行序，它也是由Java框架创建一个线程，然后执行写在它的 run() 方法肚子里的代码。现在要注意了，重点来了： 当我们点击桌面图标，桌面实际也是一个APP，上面放几个View，这些View的Image资源都是每个APP的图标，点击后就去执行的代码就是new一个进程，进程的资源什么乱七八糟的东西有一堆是根据你在APP的Manifest文件里面配置生成的。这一部分在这不讲，只需要知道，进程的必然要有一个主线程来执行APP里面写的代码吧。 在这里我们不去装逼的拿源码去讲什么第一个Activity的启动，还是按照上面的一个线程创建出要执行 run() 肚子里的代码。假如我们在里面写怎样去加载View，怎样去绘制View，然后展示出来，再然后呢，当View也绘制好了，展示出来了，界面都呈现出来了，这时代码执行序不就结束了么，按道理APP也就关掉了啊，不可能等在那让我们点击啊。其实这就是关键了，我们要想让这个主线程不执行结束，不死掉，应该还是很好解决的。比如直接在前面代码执行完以后，View显示出来了，让主线程去执行一个Whlie（true）的循环，这时不就万事大吉了么。View显示出来，一直显示着。 但是这样还有一个问题，就是主线程一直在while循环里跑，用户无法交互，主线程也无法继续执行这代码。其实这时候我们自己都能想到了，让主线程跑在while循环里，让他每次循环都去访问某个地方，看看有没有什么事要做，有就拿来做了再跑循环，没有就继续跑循环直到有事情做。其实Android整个UI机制就是这样的，装逼点说就是基于事件的机制，Windows其实也是这样的。 主线程跑在一个循环里面，而这个循环就是Looper的 loop() 方法。是时候让主角之一登场了： 说实话Looper的源码加注释真的写的相当清楚明白，而且代码量极少，我们直接看最前面关于Looper的注释： /** * Class used to run a message loop for a thread. Threads by default do * not have a message loop associated with them; to create one, call * {@link #prepare} in the thread that is to run the loop, and then * {@link #loop} to have it process messages until the loop is stopped. * * &lt;p&gt;Most interaction with a message loop is through the * {@link Handler} class. * * &lt;p&gt;This is a typical example of the implementation of a Looper thread, * using the separation of {@link #prepare} and {@link #loop} to create an * initial Handler to communicate with the Looper. * * &lt;pre&gt; * class LooperThread extends Thread { * public Handler mHandler; * * public void run() { * Looper.prepare(); * * mHandler = new Handler() { * public void handleMessage(Message msg) { * // process incoming messages here * } * }; * * Looper.loop(); * } * }&lt;/pre&gt; */ 最前面很显的写着：Looper这个类一般用于让线程去做一个消息的循环，线程里面本来是没有一个消息循环和线程相关联的。如果要创建一个有loop循环的线程，就要在线程的run方法里去调执行loop，让它在loop的过程中去处理消息。怎么样，和我前面讲的基本一样，我以宋吉吉的人格发誓，我之前没仔细看过这段注释，果然英雄所见略同。然后，注释又写了个例子，教你怎样写一个有Looper的线程。抬眼一瞅，这不就是在run方法的肚子里执行 Looer.loop() 么。。。 根据我们上面讲的线程的原理，即使不看这个 loop() 方法，先来猜一发，看看它里面会怎么写，无非是一个 while（ture) 循环，然后在里面每次有一个去消息，把消息里的代码执行的操作，好，上源码，接下来就是见证奇迹的时刻： public static void loop() { final Looper me = myLooper(); if (me == null) { throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;); } final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) { Message msg = queue.next(); // might block if (msg == null) { // No message indicates that the message queue is quitting. return; } // This must be in a local variable, in case a UI event sets the logger Printer logging = me.mLogging; if (logging != null) { logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; + msg.callback + &quot;: &quot; + msg.what); } msg.target.dispatchMessage(msg); if (logging != null) { logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback); } // Make sure that during the course of dispatching the // identity of the thread wasn&apos;t corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) { Log.wtf(TAG, &quot;Thread identity changed from 0x&quot; + Long.toHexString(ident) + &quot; to 0x&quot; + Long.toHexString(newIdent) + &quot; while dispatching to &quot; + msg.target.getClass().getName() + &quot; &quot; + msg.callback + &quot; what=&quot; + msg.what); } msg.recycleUnchecked(); } } 额额，loop() 方法是。。。日，竟然是个 for(;;) ,啪啪，这个不算打脸吧，和while(true) 一样嘛。继续看for循环里面的代码： Message msg = queue.next(); 这行就是从MessageQueue里面取一个Message，也就是从消息队列里取一个消息。如果消息是null，就丢弃掉，然后接下来自然不出我们所料要处理消息了： msg.target.dispatchMessage(msg); 这行自然就是处理消息了，这里面为什么这样写也是有技巧的，让我来解释一下（装一下逼）：因为线程在执行 loop() 的时候，并不知道要在每次循环去执行什么代码，所以在定义这个google在定义这个框架的时候，必须留一个接口，以你来写代码，框架来调用的形式定义。不看源码一切都是瞎逼逼，直接看源码，这个msg是一个Message对象，也就是一个消息，这没什么好说的。Message里有一个叫target的属性是Handler类型的： /*package*/ Handler target; 在Handler发送这个消息的时候会把Handler会把自己的引用放到这个消息的target属性里: public boolean sendMessageAtTime(Message msg, long uptimeMillis) { MessageQueue queue = mQueue; if (queue == null) { RuntimeException e = new RuntimeException( this + &quot; sendMessageAtTime() called with no mQueue&quot;); Log.w(&quot;Looper&quot;, e.getMessage(), e); return false; } return enqueueMessage(queue, msg, uptimeMillis); } private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) { msg.target = this; if (mAsynchronous) { msg.setAsynchronous(true); } return queue.enqueueMessage(msg, uptimeMillis); } 所以最终loop循环如果在消息队列里取到一个消息，就去执行发送这个消息的Handler的 dispatchMessage(msg) 方法，如果我们在去看这个方法，他一定会预留一个接口让我去写代码： public void dispatchMessage(Message msg) { if (msg.callback != null) { handleCallback(msg); } else { if (mCallback != null) { if (mCallback.handleMessage(msg)) { return; } } handleMessage(msg); } } 看到这最后调的这个方法我们应该就很熟悉了，我们平时new一个Handler一般都是这两种方式嘛： Handler handler = new Handler(new Handler.Callback() { @Override public boolean handleMessage(Message msg) { return false; } }); 或者 Handler handler = new Handler(){ @Override public void handleMessage(Message msg) { super.handleMessage(msg); } }; 这两种方法并没有什么鸟区别，一个用了接口，都是在 handleMessage(Message msg) 方法肚子里写我们要执行的代码。 再回到前面说的，线程在loop中循环，每次循环，没有消息就继续循环，取到消息就执行执行发送该消息的Handler的 dispatchMessage(Message msg) ，而这个方法最终执行的是我们填入代码的 handleMessage(Message msg) 方法。这样就实现了预留出接口，通过循环，让主线程一直取消息，然后我们通过发消息到MessageQueue，并写好收到消息后要执行的操作，让主线程来调，然后在循环过程中执行不同的代码，实现交互。 其实明白了主线程在loop循环的过程中是怎么工作的，Handler也就简单的一笔了，但是它里面还是有一些设计思想在里面。我准备多写几篇，具体到每行代码，把MessageQueue，Message，Handler的源码都拿过来晒晒，然后理解每一行代码的作用。虽然可能开发中使用不需要这么细致的理解，但是Android源码里面的设计思想还是有很多值得借鉴的地方，看着还是挺有意思的。 如果在这篇有没有看懂的地方也不用着急，因为后面会更细致的把整个涉及的知识讲完。 （本篇完，下篇待续）","tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]}]