[{"title":"GC机制梳理","date":"2017-01-22T08:25:41.000Z","path":"2017/01/22/GC机制梳理/","text":"","tags":[]},{"title":"Android开发中要打交道的那些Json","date":"2017-01-22T08:24:23.000Z","path":"2017/01/22/Android开发中要打交道的那些Json/","text":"","tags":[]},{"title":"View和ViewGroup事件处理机制梳理","date":"2017-01-22T08:23:00.000Z","path":"2017/01/22/View和ViewGroup事件处理机制梳理/","text":"","tags":[]},{"title":"Android程序猿应该了解的Http请求","date":"2017-01-22T08:21:53.000Z","path":"2017/01/22/Android程序猿应该了解的Http请求/","text":"在Android开发中最经常见到的与服务器交互的方式就是通过Http请求了。我还是按照自己的理解来说明Http请求究竟是个什么东西。尽量不去堆砌名词，用最简单的语言就像科普一样给描述出来。 首先，Http是一种网络协议，协议这种东西就是约定好用来通信的嘛。通信协议无非就是通信双方对信息传输的约定，比如我要传个1，给你个高电平，传个0，就给你个低电平。尽管Http是应用层协议，它也是一种信息传输的约定，无非是比着0或1的编码更抽象罢了。我们要理解Http协议，首先要明白我们能用Http协议做什么，然后是哪些东西是Http这一层做的事。其实我一直觉的真正不容易懂的是http协议这一层到底包括哪些东西，什么get，post，head方法，无非就是一个规则，当我们知道http是什么之后，这些规则都简单的一笔。。。（我只写自己的理解，语言也没那么严密，感性认知，不喜勿喷） 其实就像手机一样，我们可以用手机打电话，发短信，只要知道对方的号码，会拨号，或者编辑，然后打电话要打开拨号的软件，发短信要打开短信软件进行编辑。可以把Http协议的接口就抽象为一个手机，至于怎么发出去的，怎么听到声音的，怎么连接上的，这些不用我们管，在http这一层也无需理解。这样来看http，其实也就很简单了。既然我们用http来进行客户端和服务器的交互，就自然可以想到，我们是和服务器进行交换数据的。比如我要注册，必然要把注册的账号告诉服务器，让它存起来，它验证后觉得，符合注册要求，然后返回一个信息，说成功了，然后客户端再进行其他的操作。这样的信息交互无非就四种嘛，增删改查。 同时我们来看http协议的各种请求，最常用的就是get方法和post方法了，为什么这两个最常用？因为get是对应数据的查，C／S模式下这种查不难理解吧，比如新闻客户端，一个页面那么多条新闻肯定要从服务器查询啊。每次刷新的时候去查一下服务器，然后服务器把结果取出来呈现在客户端界面上。post就对应是改数据的方法，客户端一般采集数据，更新服务端数据就用post方法。我觉得这样讲get和post的方法比说什么带不带body，格式什么的好理解吧。自然你想嘛，如果我要查，用get方法，只要知道路径就可以了，我自然就可以查到了，要post，改数据，总要知道你要改的字段是什么，你要更改为什么数据。所以post要放参数也就是这个原因了，就这么简单，我不知道为什么那些讲http请求的为什么老是搬书，上来就是定义，每次学一个新东西都很费劲。我觉得有这个理解，后面每一块是干嘛的其实很好理解的。","tags":[]},{"title":"不开玩笑，我只想认真谈技术","date":"2017-01-22T08:21:03.000Z","path":"2017/01/22/不开玩笑，我只想认真谈技术/","text":"项目告一段落，突然放松下来，又感觉有些迷茫了。可能这就是人的通病吧，看看博客，想想明年的规划，总觉得自己没有足够的努力。不是什么鸡汤，也总觉得自己能够做到更好。 可能接触的时间不够吧，想想自己肚里的那点墨水总是发虚，一个连c++都没有敲过一行的人，底层的JNI都看不懂怎么能说自己会编程呢？虽然从职业发展角度上来说，如果你在某个小领域特别精通，可能会收获更多的财富和声望，但是总觉得这些不是自己真正想要的。打心底里还是有一种求知欲，一种从上至下贯通的求知欲，每次看到一些全栈在侃侃而谈什么逆向，Linux系统通信，这种欲望便更加难以克制，然后再懒散的等那股劲过了，告诉自己洗洗睡吧，我只是一个Android应用开发的Coder。我想弄懂这些东西，就像对我的掌纹一样了解，紧紧的握在手里，伸开能清晰的看出每一条脉络的去向。 所以我这这一口气写了多篇博客 的标题，来督促自己接下来的一段时间内要梳理和内化的一些知识点。当然这些知识都是在Android APP开发层面的。我的想法是，先把这个层面要掌握的快速的沉淀下来，然后转到下一个阵地，开始着手去code，code，code。。。 对，就是这样","tags":[]},{"title":"Handler再一次回顾（二）","date":"2016-12-19T09:38:49.000Z","path":"2016/12/19/Handler再一次回顾（二）/","text":"在Handler再一次回顾里，我主要讲到了主线程在Looper的loop里循环读取消息，然后处理消息的过程，并没有说明这个消息是怎样发送的。这一篇我准备继续顺着线程执行的顺序来一步步看，怎样从发送消息到处理一个消息，以及消息究竟是个什么东西。 在接着上一篇思路往下走之前，先说一点关于进程和APP的东西。多进程的东西在此不涉及，默认我们的APP只有一个进程，当点击APP图标，需要启动一个APP时，系统为我们用孵化出一个新进程，用来执行这个APP的代码。这个新进程里面的有个线程，就是我们的主线程，同时这个主线程和其他线程的区别就是有一个Looper和MessageQueue。简单来说就是：点击APP图标后系统为我们做的事就是孵化出一个进程，进程里有一个主线程，主线程里面有个Looper，MessageQueue，然后让执行到Looper的loop循环里。这个时候主线程就在这个loop里面跑循环，每次去取消息来处理了。 然后我们再想一个问题，既然主线程都在跑圈圈了，我们怎么让主线程去显示界面呢，Activity在哪创建呢，又是如何执行到Activity的 onCreate() 方法的呢？其实这个问题的答案很好想到，只要给主线程的MessageQueue发消息，就可以了。而系统也正是这样做的， onCreate() 是由系统给主线程发消息到主线程的MessageQueue中，当loop循环取到这个消息的时候，处理消息也就是执行 onCreate() 肚子里的代码。从loop循环里面到 onCreate() 肚子里面代码的执行过程跟上篇讲的执行Handler的 handleMesaage() 方法的是一样的。 从上一篇到现在，基本上基于事件的线程的窗口机制的模型已经说清楚了。只剩下具体每一部分的细节了，比如具体怎样发消息，发到哪，取消息，从哪取，怎样取？针对这些细节，我们再根据源码，进行细致的说明。 先不急于看源码，我们先做一件事，就是自己猜，忘掉以前对Handler的认知。猜Google是怎样实现的。因为这样我们才能了解google设计这个东西的时候究竟是怎样想的，他的代码妙在什么地方，然后才对整个知识点有更深刻的认知。先不要觉得我在瞎几把扯，我真的觉得这样的理解才是顺其自然的，真正弄懂了这个东西，而不是死记硬背，含糊不清。 现在我们有四个类，Looper，Handler，Message，MessageQueue：目前来说我们仅知道的内容就是主线程跑到Looper的 loop() 循环里面，Handler 发送消息到MessgeQueue，Looper的loop中要从MessageQueue拿出消息，然后最终在Handler的handleMessage里取处理消息。 基于上面的认知我们如果设计的话，至少要Handler在调sendMessge方法的时候应该是拿到了MessageQueue的引用，然后Looper取消息的时候肯定也要有MessageQueue的引用。message被取出来的时候调要找到handler并调用它的handleMessage方法，所以，message也应该持有Handler的引用。有了这些认知以后再去看源码就相当简单了，甚至说自己都能设计出简化版。下面顺着发消息到MessageQueue，再从MessageQueue里面取消息去处理的过程撸一遍源码： 先从new一个Handler开始，看Handler的构造方法： public Handler(Callback callback, boolean async) { if (FIND_POTENTIAL_LEAKS) { final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) { Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; + klass.getCanonicalName()); } } mLooper = Looper.myLooper(); if (mLooper == null) { throw new RuntimeException( &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;); } mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async; } public Handler(Looper looper, Callback callback, boolean async) { mLooper = looper; mQueue = looper.mQueue; mCallback = callback; mAsynchronous = async; } 在这里我只罗列了两个构造方法，其他的构造方法最终还是要调到这两个构造方法（这种写法在Android源码里随处可见，包括我们发送sendMessage和postMessage，或者延时发送消息最终都是调的同一个发送消息的方法）。从这两个方法我们可以看出Handler发送消息对MessageQueue的引用时通过： mQueue = looper.mQueue; 这就说明对MessageQueue的所有引用都在Looper中的，而整个线程的MessageQueue就是looper.mQueue。而Handler持有的是Looper的引用。无论是添加消息还是摘取消息都是拿的looper.mQueue来操作的。然后我们再去看sendMessage时添加一条消息到looper.mQueue： public boolean sendMessageAtTime(Message msg, long uptimeMillis) { MessageQueue queue = mQueue; if (queue == null) { RuntimeException e = new RuntimeException( this + &quot; sendMessageAtTime() called with no mQueue&quot;); Log.w(&quot;Looper&quot;, e.getMessage(), e); return false; } return enqueueMessage(queue, msg, uptimeMillis); } private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) { msg.target = this; if (mAsynchronous) { msg.setAsynchronous(true); } return queue.enqueueMessage(msg, uptimeMillis); } sendMessage和postRunnable有好几种方法，比如 sendMessageDelayed(Message msg, long delayMillis) 和 postDelayed(Runnable r, long delayMillis) 还有另外几个，他们最终调的都是 sendMessageAtTime(Message msg, long uptimeMillis) 其实并没有什么区别，都是在某个时刻发送一个message的方式来实现的，其中延时： sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis); 由上面的Handler的enqueueMessage方法可以看出，Handler其实只是算出在什么时候发送消息，并把它作为参数传给了messageQueue，但是并没有等待到那个时间去发送，而是立即交给了MessageQueue去处理。由此便知道MessageQueue里面要么在插入消息时有一个等待过程，要么在摘取消息时有一个等待过程，然后我们继续看源码： boolean enqueueMessage(Message msg, long when) { if (msg.target == null) { throw new IllegalArgumentException(&quot;Message must have a target.&quot;); } if (msg.isInUse()) { throw new IllegalStateException(msg + &quot; This message is already in use.&quot;); } synchronized (this) { if (mQuitting) { IllegalStateException e = new IllegalStateException( msg.target + &quot; sending message to a Handler on a dead thread&quot;); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; } msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) { // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; } else { // Inserted within the middle of the queue. Usually we don&apos;t have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) { prev = p; p = p.next; if (p == null || when &lt; p.when) { break; } if (needWake &amp;&amp; p.isAsynchronous()) { needWake = false; } } msg.next = p; // invariant: p == prev.next prev.next = msg; } // We can assume mPtr != 0 because mQuitting is false. if (needWake) { nativeWake(mPtr); } } return true; } 上面的代码也比较简单： 因为MessageQueue插入操作可能来自不同线程，所以在执行插入操作时加锁，然后从这里可以看出消息队列实际上是通过链表实现的，mMessages是当前链表的头，明白了这些之后，整个代码主要就是根据message里面的时间（也就是我们在sendMessageAtTime传进来的那个时间）来判断当前入队列的这个message应该插入到链表的哪个位置，来保证整个链表是一个按时间先后排序的链表。 现在已经执行完了 enqueueMessage(Message msg, long when) 的代码，下一步应该是摘取消息来进行处理了，上篇说过，主线程在loop里绕圈，每次都去摘取一条消息进行处理，摘取消息的代码上一篇已经贴出，在loop里面： Message msg = queue.next(); // might block 摘取消息的代码稍长，而且也有点不是很好理解，因为这里面关系到同步消息和异步消息处理机制不同的问题，需要做一些铺垫才能讲的明白。现在我们先按自己的理解继续往下走，消息队列是一个链表实现的，然后时间先后顺序已经排好了，按我们的理解应该就是每次loop的过程来取消息，拿系统当前时间和链表头部的第一条消息的时间进行对比，到第一条执行时间就让它去执行，时间不到就返回一个null。 当然这只是我们的猜想，系统的实现方式比这要复杂一点，但是也复杂不了太多，下面来看queue.next()要执行的代码； Message next() { // Return here if the message loop has already quit and been disposed. // This can happen if the application tries to restart a looper after quit // which is not supported. final long ptr = mPtr; if (ptr == 0) { return null; } int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) { if (nextPollTimeoutMillis != 0) { Binder.flushPendingCommands(); } nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) { // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) { // Stalled by a barrier. Find the next asynchronous message in the queue. do { prevMsg = msg; msg = msg.next; } while (msg != null &amp;&amp; !msg.isAsynchronous()); } if (msg != null) { if (now &lt; msg.when) { // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); } else { // Got a message. mBlocked = false; if (prevMsg != null) { prevMsg.next = msg.next; } else { mMessages = msg.next; } msg.next = null; if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg); msg.markInUse(); return msg; } } else { // No more messages. nextPollTimeoutMillis = -1; } // Process the quit message now that all pending messages have been handled. if (mQuitting) { dispose(); return null; } // If first time idle, then get the number of idlers to run. // Idle handles only run if the queue is empty or if the first message // in the queue (possibly a barrier) is due to be handled in the future. if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) { pendingIdleHandlerCount = mIdleHandlers.size(); } if (pendingIdleHandlerCount &lt;= 0) { // No idle handlers to run. Loop and wait some more. mBlocked = true; continue; } if (mPendingIdleHandlers == null) { mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; } mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); } // Run the idle handlers. // We only ever reach this code block during the first iteration. for (int i = 0; i &lt; pendingIdleHandlerCount; i++) { final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handler boolean keep = false; try { keep = idler.queueIdle(); } catch (Throwable t) { Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t); } if (!keep) { synchronized (this) { mIdleHandlers.remove(idler); } } } // Reset the idle handler count to 0 so we do not run them again. pendingIdleHandlerCount = 0; // While calling an idle handler, a new message could have been delivered // so go back and look again for a pending message without waiting. nextPollTimeoutMillis = 0; } } 和我们想的并不一样，这里面也有一个死循环来摘取下一条消息，而我们再看下loop里面取下一条消息的注释： Message msg = queue.next(); // might block 有可能阻塞？对，其实loop时从MessgeQueue里摘取下一条消息的过程并不是直接返回的，而是有可能在MessageQueue.next()里面阻塞住的，我们还是看代码：nextPollTimeoutMillis这个变量就是通过messge上携带的时间减去当前时间。然后用到这个时间的只有一个地方： nativePollOnce(ptr, nextPollTimeoutMillis); 这个方法实际上就是去调C++的代码，让当前线程等待管道阻塞一段时间，传进去的也就是阻塞时间。什么管道乱七八糟的不懂也没关系，就是让当前线程阻塞住这么长时间。至于为什么是阻塞而不是让线程空转，这里有很多考虑在里面，让我这样的小白不得感叹一句，Google的工程师真的6。在这里讲下我个人的一些理解： 我们可以从JVM假想有个cpu存在，这不难理解吧，JVM本来就是虚拟机，然后主线程如果一直空转的话，不管cpu采用哪种调度策略，主线程都有可能在这一段时间得到cpu的使用权，而它执行的代码竟然是空转，这是没必要的，反正它这段时间没有消息，主线程就是通过loop摘取消息才执行的，离下一条要执行的消息既然还有时间，那就让线程在这段时间阻塞了也无妨。 第二个就是为gc考虑了。Android最重要的就是用户体验，响应速度，而Java的gc垃圾回收刚好是和这个目标相悖，因为gc的时候要：stop the world，就是要所有的东西都停下来，gc完了你们再执行。如果一个正在打字和MM聊天的用户突然被gc卡了一下，会不会觉得很不爽（当然没那么明显，但是还是肯定要考虑gc的时间的）。而这个主线程阻塞的时间既不会影响用户交互，干嘛不用来gc呢，至于其他线程，只要不是UI线程，gc阻碍一会又有什么关系呢。所以这个时间也可以给gc来考虑要不要gc。 到此摘取消息也讲的差不多了，我们之前已经讲过了处理消息的过程，消息机制的基本功能已经讲完了。 ###TODO：不过我还是有所保留的，对同步消息和异步消息这一块还没讲，然后对IdleHandler这一块也没有讲，还有就是Looper为什么要用ThreadLocal而不是用synchronized。因为要想讲明白这些，必须一层一层的往下走，先有一个基本的框架，然后再去看同步消息和异步消息其实也就是两个不同的消息类型而已，然后再取消息的过程有一点点区别，有一个时间分割栏的概念。主要还是为了让UI更流畅的显示的，平时开发基本用不着，在读View相关的源码的时候经常碰到，先有个这个印象。Looper用ThreadLocal也是基于让主线程在loop时不必因其他线程锁住Looper而等待（如果用synchronized，当其他线程用sendMessage时要拿到从Handler到Looper再到MessageQueue的引用，这是就要对Looper进行加锁。）（本篇完，下篇待续）","tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"Handler再一次回顾","date":"2016-12-17T11:19:57.000Z","path":"2016/12/17/Handler再一次回顾/","text":"只要是做过Android开发的，想必对Handler都不陌生。在我刚工作的时候就去看过Handler的源码，但当时局限于对多线程的理解并没有那么深刻，所以对Handler的理解也就仅仅停留在表面。现在有时间重看Handler源码，猛然发现：我擦，Handler这么简单，竟然好多面试都去问，好多人都是马马虎虎，一知半解。所以我想在这篇博客里，把Handler彻底讲透了，以后妈妈再也不用担心我对Handler的理解了。 其实很多人对Handler的不理解，关键还在于对线程的不理解，所以我决定先简单说下线程的相关的知识。我在这也不能跟你胡说，在Java里一切都是对象，我们先看下Java源码里线程类的注释： /** * A {@code Thread} is a concurrent unit of execution. It has its own call stack * for methods being invoked, their arguments and local variables. Each application * has at least one thread running when it is started, the main thread, in the main * {@link ThreadGroup}. The runtime keeps its own threads in the system thread * group. * * &lt;p&gt;There are two ways to execute code in a new thread. * You can either subclass {@code Thread} and overriding its {@link #run()} method, * or construct a new {@code Thread} and pass a {@link Runnable} to the constructor. * In either case, the {@link #start()} method must be called to actually execute * the new {@code Thread}. * * &lt;p&gt;Each {@code Thread} has an integer priority that affect how the thread is * scheduled by the OS. A new thread inherits the priority of its parent. * A thread&apos;s priority can be set using the {@link #setPriority(int)} method. */ 我在这也不逐行去翻译了，英语能看懂的就看看，按我的理解就是：线程就是一个执行序，有自己的执行栈。完了，就这么多。我知道这么说对于初学者者来说，肯定会在下面骂了，妈蛋，什么是执行序啊？先别急，把刀放下，咱慢慢说。我们写代码时，这个方法，那个对象，一堆乱七八糟的东西，要执行出一个确定的结果，肯定是要一个确定的顺序。包括多线程，只要逻辑上有先后顺序的信息，也一定要保证按确定的顺序来执行。 现在来想一下我们平时听了八百遍的多线程实现方式，实现 Runnable 接口，或者 new Thread() ，一个新的线程，我们不要忘了去调它的 start() 方法。这时才真正的启动了一个线程，去执行我们写在 run() 方法里的代码。其实从Android APP开发者的角度来讲，Thread的 run()就相当于Java框架给我们的一个执行代码的入口，让CPU来执行我们的代码（这么说当然是扯淡，但是你仅从APP开发者敲代码的角度去看，把编译，链接，虚拟机，操作系统全看成透明的，也就是这么个理）。 我们只要写好自己的代码，代码放进去 run() 的肚子里，然后按下开关(执行 start() 方法)，他就一直按我们写好的顺序调下去，直到所有代码执行结束。必须明白的一点是线程就是一个执行序，在Java里，他是一个类，我们要执行的代码要放到他的 run() 的肚子里面。然后调 start() 告诉 Java虚拟机，给我开一线程的执行环境，开启后来执行我写在 run() 里的代码。 有了这个认知以后我们再来看Thread的源码： public class Thread implements Runnable 这里看到的是Thread实现了Runnable接口，接着看下Runnable接口里面都定了哪些抽象方法： public interface Runnable { /** * Starts executing the active part of the class&apos; code. This method is * called when a thread is started that has been created with a class which * implements {@code Runnable}. */ public void run(); } 整个Runnable接口就这么可怜的一个 run() 方法。继续看Thread怎么实现的 run() 方法。 Runnable target; public void run() { if (target != null) { target.run(); } } 这里可以很清楚的看出来，无论是我们继承Runnable接口，还是直接new Thread实际上是没有区别的。都是最终要把需要执行的代码放到 Thread run() 的肚子里。然后调 start() 方法 public synchronized void start() { checkNotStarted(); hasBeenStarted = true; nativeCreate(this, stackSize, daemon); } start()这里就很显了 nativeCreate() 看名字就知道是调用C或C++去创建一个线程了，而创建线程以后呢，自然去调 run() 方法肚子里我们写的代码来执行了。 这时我们已经理解了我们Java层线程的意义。至于什么去stop线程啦，设置线程优先级，让线程去sleep啦，和start（）基本一样的，是交给Java框架（这里框架这个词可能不太好理解，容易误解为J2EE的框架。其实这样说是相当于把JDK当作一种框架来看，就像Android里用的FrameWork框架。）来处理的。不是我们调了这个方法就执行的，而是我们只能通过框架给我们写好的，暴露出来的接口，去跟框架交互，至于它背后是同步，异步，或者等两秒，或者怎样搞，这些只是线程具体实现上的事，跟我们理解这个线程是一个执行序没有一毛钱的关系。如果想对线程有更深入的了解，理解线程特性，可以去看一些JVM的书（比如，深入理解Java虚拟机），里面有具体的线程特性。 到了这里发现简单说下线程，似乎说了好多，并没有收住，还将继续说下去，其实还是想尽力说的明白些，因为从个人的经验来看，对线程的理解直接决定了对Handler的理解，懂线程的根本就不会不懂Handler，懂Handler不懂线程的，绕了几圈还是会晕。而且，我以前在学习Android的时候也被好多不负责任的博客折磨的死去活来。所以我最讨厌那种上来就甩你一脸定义，代码，专有名词，乱七八糟的东西，老子懂这些的话还看你在这逼逼？ 扯远了，继续说线程，刚刚说线程就是执行序，那么主线程呢？（在Android里一般主线程，UI线程，main线程都是在说一个玩意：主线程）。主线程既然是线程，它也是一个执行序，它也是由Java框架创建一个线程，然后执行写在它的 run() 方法肚子里的代码。现在要注意了，重点来了： 当我们点击桌面图标，桌面实际也是一个APP，上面放几个View，这些View的Image资源都是每个APP的图标，点击后就去执行的代码就是new一个进程，进程的资源什么乱七八糟的东西有一堆是根据你在APP的Manifest文件里面配置生成的。这一部分在这不讲，只需要知道，进程的必然要有一个主线程来执行APP里面写的代码吧。 在这里我们不去装逼的拿源码去讲什么第一个Activity的启动，还是按照上面的一个线程创建出要执行 run() 肚子里的代码。假如我们在里面写怎样去加载View，怎样去绘制View，然后展示出来，再然后呢，当View也绘制好了，展示出来了，界面都呈现出来了，这时代码执行序不就结束了么，按道理APP也就关掉了啊，不可能等在那让我们点击啊。其实这就是关键了，我们要想让这个主线程不执行结束，不死掉，应该还是很好解决的。比如直接在前面代码执行完以后，View显示出来了，让主线程去执行一个Whlie（true）的循环，这时不就万事大吉了么。View显示出来，一直显示着。 但是这样还有一个问题，就是主线程一直在while循环里跑，用户无法交互，主线程也无法继续执行这代码。其实这时候我们自己都能想到了，让主线程跑在while循环里，让他每次循环都去访问某个地方，看看有没有什么事要做，有就拿来做了再跑循环，没有就继续跑循环直到有事情做。其实Android整个UI机制就是这样的，装逼点说就是基于事件的机制，Windows其实也是这样的。 主线程跑在一个循环里面，而这个循环就是Looper的 loop() 方法。是时候让主角之一登场了： 说实话Looper的源码加注释真的写的相当清楚明白，而且代码量极少，我们直接看最前面关于Looper的注释： /** * Class used to run a message loop for a thread. Threads by default do * not have a message loop associated with them; to create one, call * {@link #prepare} in the thread that is to run the loop, and then * {@link #loop} to have it process messages until the loop is stopped. * * &lt;p&gt;Most interaction with a message loop is through the * {@link Handler} class. * * &lt;p&gt;This is a typical example of the implementation of a Looper thread, * using the separation of {@link #prepare} and {@link #loop} to create an * initial Handler to communicate with the Looper. * * &lt;pre&gt; * class LooperThread extends Thread { * public Handler mHandler; * * public void run() { * Looper.prepare(); * * mHandler = new Handler() { * public void handleMessage(Message msg) { * // process incoming messages here * } * }; * * Looper.loop(); * } * }&lt;/pre&gt; */ 最前面很显的写着：Looper这个类一般用于让线程去做一个消息的循环，线程里面本来是没有一个消息循环和线程相关联的。如果要创建一个有loop循环的线程，就要在线程的run方法里去调执行loop，让它在loop的过程中去处理消息。怎么样，和我前面讲的基本一样，我以宋吉吉的人格发誓，我之前没仔细看过这段注释，果然英雄所见略同。然后，注释又写了个例子，教你怎样写一个有Looper的线程。抬眼一瞅，这不就是在run方法的肚子里执行 Looer.loop() 么。。。 根据我们上面讲的线程的原理，即使不看这个 loop() 方法，先来猜一发，看看它里面会怎么写，无非是一个 while（ture) 循环，然后在里面每次有一个去消息，把消息里的代码执行的操作，好，上源码，接下来就是见证奇迹的时刻： public static void loop() { final Looper me = myLooper(); if (me == null) { throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;); } final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) { Message msg = queue.next(); // might block if (msg == null) { // No message indicates that the message queue is quitting. return; } // This must be in a local variable, in case a UI event sets the logger Printer logging = me.mLogging; if (logging != null) { logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; + msg.callback + &quot;: &quot; + msg.what); } msg.target.dispatchMessage(msg); if (logging != null) { logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback); } // Make sure that during the course of dispatching the // identity of the thread wasn&apos;t corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) { Log.wtf(TAG, &quot;Thread identity changed from 0x&quot; + Long.toHexString(ident) + &quot; to 0x&quot; + Long.toHexString(newIdent) + &quot; while dispatching to &quot; + msg.target.getClass().getName() + &quot; &quot; + msg.callback + &quot; what=&quot; + msg.what); } msg.recycleUnchecked(); } } 额额，loop() 方法是。。。日，竟然是个 for(;;) ,啪啪，这个不算打脸吧，和while(true) 一样嘛。继续看for循环里面的代码： Message msg = queue.next(); 这行就是从MessageQueue里面取一个Message，也就是从消息队列里取一个消息。如果消息是null，就丢弃掉，然后接下来自然不出我们所料要处理消息了： msg.target.dispatchMessage(msg); 这行自然就是处理消息了，这里面为什么这样写也是有技巧的，让我来解释一下（装一下逼）：因为线程在执行 loop() 的时候，并不知道要在每次循环去执行什么代码，所以在定义这个google在定义这个框架的时候，必须留一个接口，以你来写代码，框架来调用的形式定义。不看源码一切都是瞎逼逼，直接看源码，这个msg是一个Message对象，也就是一个消息，这没什么好说的。Message里有一个叫target的属性是Handler类型的： /*package*/ Handler target; 在Handler发送这个消息的时候会把Handler会把自己的引用放到这个消息的target属性里: public boolean sendMessageAtTime(Message msg, long uptimeMillis) { MessageQueue queue = mQueue; if (queue == null) { RuntimeException e = new RuntimeException( this + &quot; sendMessageAtTime() called with no mQueue&quot;); Log.w(&quot;Looper&quot;, e.getMessage(), e); return false; } return enqueueMessage(queue, msg, uptimeMillis); } private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) { msg.target = this; if (mAsynchronous) { msg.setAsynchronous(true); } return queue.enqueueMessage(msg, uptimeMillis); } 所以最终loop循环如果在消息队列里取到一个消息，就去执行发送这个消息的Handler的 dispatchMessage(msg) 方法，如果我们在去看这个方法，他一定会预留一个接口让我去写代码： public void dispatchMessage(Message msg) { if (msg.callback != null) { handleCallback(msg); } else { if (mCallback != null) { if (mCallback.handleMessage(msg)) { return; } } handleMessage(msg); } } 看到这最后调的这个方法我们应该就很熟悉了，我们平时new一个Handler一般都是这两种方式嘛： Handler handler = new Handler(new Handler.Callback() { @Override public boolean handleMessage(Message msg) { return false; } }); 或者 Handler handler = new Handler(){ @Override public void handleMessage(Message msg) { super.handleMessage(msg); } }; 这两种方法并没有什么鸟区别，一个用了接口，都是在 handleMessage(Message msg) 方法肚子里写我们要执行的代码。 再回到前面说的，线程在loop中循环，每次循环，没有消息就继续循环，取到消息就执行执行发送该消息的Handler的 dispatchMessage(Message msg) ，而这个方法最终执行的是我们填入代码的 handleMessage(Message msg) 方法。这样就实现了预留出接口，通过循环，让主线程一直取消息，然后我们通过发消息到MessageQueue，并写好收到消息后要执行的操作，让主线程来调，然后在循环过程中执行不同的代码，实现交互。 其实明白了主线程在loop循环的过程中是怎么工作的，Handler也就简单的一笔了，但是它里面还是有一些设计思想在里面。我准备多写几篇，具体到每行代码，把MessageQueue，Message，Handler的源码都拿过来晒晒，然后理解每一行代码的作用。虽然可能开发中使用不需要这么细致的理解，但是Android源码里面的设计思想还是有很多值得借鉴的地方，看着还是挺有意思的。 如果在这篇有没有看懂的地方也不用着急，因为后面会更细致的把整个涉及的知识讲完。 （本篇完，下篇待续）","tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]}]