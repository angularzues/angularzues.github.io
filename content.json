[{"title":"Handler再一次回顾（二）","date":"2016-12-19T09:38:49.000Z","path":"2016/12/19/Handler再一次回顾（二）/","text":"在Handler再一次回顾里，我主要讲到了主线程在Looper的loop里循环读取消息，然后处理消息的过程，并没有说明这个消息是怎样发送的。这一篇我准备继续顺着线程执行的顺序来一步步看，怎样从发送消息到处理一个消息，以及消息究竟是个什么东西。 在接着上一篇思路往下走之前，先说一点关于进程和APP的东西。多进程的东西在此不涉及，默认我们的APP只有一个进程，当点击APP图标，需要启动一个APP时，系统为我们用孵化出一个新进程，用来执行这个APP的代码。这个新进程里面的有个线程，就是我们的主线程，同时这个主线程和其他线程的区别就是有一个Looper和MessageQueue。简单来说就是：点击APP图标后系统为我们做的事就是孵化出一个进程，进程里有一个主线程，主线程里面有个Looper，MessageQueue，然后让执行到Looper的loop循环里。这个时候主线程就在这个loop里面跑循环，每次去取消息来处理了。 然后我们再想一个问题，既然主线程都在跑圈圈了，我们怎么让主线程去显示界面呢，Activity在哪创建呢，又是如何执行到Activity的 onCreate() 方法的呢？其实这个问题的答案很好想到，只要给主线程的MessageQueue发消息，就可以了。而系统也正是这样做的， onCreate() 是由系统给主线程发消息到主线程的MessageQueue中，当loop循环取到这个消息的时候，处理消息也就是执行 onCreate() 肚子里的代码。从loop循环里面到 onCreate() 肚子里面代码的执行过程跟上篇讲的执行Handler的 handleMesaage() 方法的是一样的。 从上一篇到现在，基本上基于事件的线程的窗口机制的模型已经说清楚了。只剩下具体每一部分的细节了，比如具体怎样发消息，发到哪，取消息，从哪取，怎样取？针对这些细节，我们再根据源码，进行细致的说明。 先不急于看源码，我们先做一件事，就是自己猜，忘掉以前对Handler的认知。猜Google是怎样实现的。因为这样我们才能了解google设计这个东西的时候究竟是怎样想的，他的代码妙在什么地方，然后才对整个知识点有更深刻的认知。先不要觉得我在瞎几把扯，我真的觉得这样的理解才是顺其自然的，真正弄懂了这个东西，而不是死记硬背，含糊不清。 现在我们有四个类，Looper，Handler，Message，MessageQueue：目前来说我们仅知道的内容就是主线程跑到Looper的 loop() 循环里面，Handler 发送消息到MessgeQueue，Looper的loop中要从MessageQueue拿出消息，然后最终在Handler的handleMessage里取处理消息。 基于上面的认知我们如果设计的话，至少要Handler在调sendMessge方法的时候应该是拿到了MessageQueue的引用，然后Looper取消息的时候肯定也要有MessageQueue的引用。message被取出来的时候调要找到handler并调用它的handleMessage方法，所以，message也应该持有Handler的引用。有了这些认知以后再去看源码就相当简单了，甚至说自己都能设计出简化版。下面顺着发消息到MessageQueue，再从MessageQueue里面取消息去处理的过程撸一遍源码： 先从new一个Handler开始，看Handler的构造方法： public Handler(Callback callback, boolean async) { if (FIND_POTENTIAL_LEAKS) { final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) { Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; + klass.getCanonicalName()); } } mLooper = Looper.myLooper(); if (mLooper == null) { throw new RuntimeException( &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;); } mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async; } public Handler(Looper looper, Callback callback, boolean async) { mLooper = looper; mQueue = looper.mQueue; mCallback = callback; mAsynchronous = async; } 在这里我只罗列了两个构造方法，其他的构造方法最终还是要调到这两个构造方法（这种写法在Android源码里随处可见，包括我们发送sendMessage和postMessage，或者延时发送消息最终都是调的同一个发送消息的方法）。从这两个方法我们可以看出Handler发送消息对MessageQueue的引用时通过： mQueue = looper.mQueue; 这就说明对MessageQueue的所有引用都在Looper中的，而整个线程的MessageQueue就是looper.mQueue。而Handler持有的是Looper的引用。无论是添加消息还是摘取消息都是拿的looper.mQueue来操作的。然后我们再去看sendMessage时添加一条消息到looper.mQueue： public boolean sendMessageAtTime(Message msg, long uptimeMillis) { MessageQueue queue = mQueue; if (queue == null) { RuntimeException e = new RuntimeException( this + &quot; sendMessageAtTime() called with no mQueue&quot;); Log.w(&quot;Looper&quot;, e.getMessage(), e); return false; } return enqueueMessage(queue, msg, uptimeMillis); } private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) { msg.target = this; if (mAsynchronous) { msg.setAsynchronous(true); } return queue.enqueueMessage(msg, uptimeMillis); } sendMessage和postRunnable有好几种方法，比如 sendMessageDelayed(Message msg, long delayMillis) 和 postDelayed(Runnable r, long delayMillis) 还有另外几个，他们最终调的都是 sendMessageAtTime(Message msg, long uptimeMillis) 其实并没有什么区别，都是在某个时刻发送一个message的方式来实现的，其中延时： sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis); 由上面的Handler的enqueueMessage方法可以看出，Handler其实只是算出在什么时候发送消息，并把它作为参数传给了messageQueue，但是并没有等待到那个时间去发送，而是立即交给了MessageQueue去处理。由此便知道MessageQueue里面要么在插入消息时有一个等待过程，要么在摘取消息时有一个等待过程，然后我们继续看源码： boolean enqueueMessage(Message msg, long when) { if (msg.target == null) { throw new IllegalArgumentException(&quot;Message must have a target.&quot;); } if (msg.isInUse()) { throw new IllegalStateException(msg + &quot; This message is already in use.&quot;); } synchronized (this) { if (mQuitting) { IllegalStateException e = new IllegalStateException( msg.target + &quot; sending message to a Handler on a dead thread&quot;); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; } msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) { // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; } else { // Inserted within the middle of the queue. Usually we don&apos;t have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) { prev = p; p = p.next; if (p == null || when &lt; p.when) { break; } if (needWake &amp;&amp; p.isAsynchronous()) { needWake = false; } } msg.next = p; // invariant: p == prev.next prev.next = msg; } // We can assume mPtr != 0 because mQuitting is false. if (needWake) { nativeWake(mPtr); } } return true; } 上面的代码也比较简单： 因为MessageQueue插入操作可能来自不同线程，所以在执行插入操作时加锁，然后从这里可以看出消息队列实际上是通过链表实现的，mMessages是当前链表的头，明白了这些之后，整个代码主要就是根据message里面的时间（也就是我们在sendMessageAtTime传进来的那个时间）来判断当前入队列的这个message应该插入到链表的哪个位置，来保证整个链表是一个按时间先后排序的链表。 现在已经执行完了 enqueueMessage(Message msg, long when) 的代码，下一步应该是摘取消息来进行处理了，上篇说过，主线程在loop里绕圈，每次都去摘取一条消息进行处理，摘取消息的代码上一篇已经贴出，在loop里面： Message msg = queue.next(); // might block 摘取消息的代码稍长，而且也有点不是很好理解，因为这里面关系到同步消息和异步消息处理机制不同的问题，需要做一些铺垫才能讲的明白。现在我们先按自己的理解继续往下走，消息队列是一个链表实现的，然后时间先后顺序已经排好了，按我们的理解应该就是每次loop的过程来取消息，拿系统当前时间和链表头部的第一条消息的时间进行对比，到第一条执行时间就让它去执行，时间不到就返回一个null。 当然这只是我们的猜想，系统的实现方式比这要复杂一点，但是也复杂不了太多，下面来看queue.next()要执行的代码； Message next() { // Return here if the message loop has already quit and been disposed. // This can happen if the application tries to restart a looper after quit // which is not supported. final long ptr = mPtr; if (ptr == 0) { return null; } int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) { if (nextPollTimeoutMillis != 0) { Binder.flushPendingCommands(); } nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) { // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) { // Stalled by a barrier. Find the next asynchronous message in the queue. do { prevMsg = msg; msg = msg.next; } while (msg != null &amp;&amp; !msg.isAsynchronous()); } if (msg != null) { if (now &lt; msg.when) { // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); } else { // Got a message. mBlocked = false; if (prevMsg != null) { prevMsg.next = msg.next; } else { mMessages = msg.next; } msg.next = null; if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg); msg.markInUse(); return msg; } } else { // No more messages. nextPollTimeoutMillis = -1; } // Process the quit message now that all pending messages have been handled. if (mQuitting) { dispose(); return null; } // If first time idle, then get the number of idlers to run. // Idle handles only run if the queue is empty or if the first message // in the queue (possibly a barrier) is due to be handled in the future. if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) { pendingIdleHandlerCount = mIdleHandlers.size(); } if (pendingIdleHandlerCount &lt;= 0) { // No idle handlers to run. Loop and wait some more. mBlocked = true; continue; } if (mPendingIdleHandlers == null) { mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; } mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); } // Run the idle handlers. // We only ever reach this code block during the first iteration. for (int i = 0; i &lt; pendingIdleHandlerCount; i++) { final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handler boolean keep = false; try { keep = idler.queueIdle(); } catch (Throwable t) { Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t); } if (!keep) { synchronized (this) { mIdleHandlers.remove(idler); } } } // Reset the idle handler count to 0 so we do not run them again. pendingIdleHandlerCount = 0; // While calling an idle handler, a new message could have been delivered // so go back and look again for a pending message without waiting. nextPollTimeoutMillis = 0; } } 和我们想的并不一样，这里面也有一个死循环来摘取下一条消息，而我们再看下loop里面取下一条消息的注释： Message msg = queue.next(); // might block 有可能阻塞？对，其实loop时从MessgeQueue里摘取下一条消息的过程并不是直接返回的，而是有可能在MessageQueue.next()里面阻塞住的，我们还是看代码：nextPollTimeoutMillis这个变量就是通过messge上携带的时间减去当前时间。然后用到这个时间的只有一个地方： nativePollOnce(ptr, nextPollTimeoutMillis); 这个方法实际上就是去调C++的代码，让当前线程等待管道阻塞一段时间，传进去的也就是阻塞时间。什么管道乱七八糟的不懂也没关系，就是让当前线程阻塞住这么长时间。至于为什么是阻塞而不是让线程空转，这里有很多考虑在里面，让我这样的小白不得感叹一句，Google的工程师真的6。在这里讲下我个人的一些理解： 我们可以从JVM假想有个cpu存在，这不难理解吧，JVM本来就是虚拟机，然后主线程如果一直空转的话，不管cpu采用哪种调度策略，主线程都有可能在这一段时间得到cpu的使用权，而它执行的代码竟然是空转，这是没必要的，反正它这段时间没有消息，主线程就是通过loop摘取消息才执行的，离下一条要执行的消息既然还有时间，那就让线程在这段时间阻塞了也无妨。 第二个就是为gc考虑了。Android最重要的就是用户体验，响应速度，而Java的gc垃圾回收刚好是和这个目标相悖，因为gc的时候要：stop the world，就是要所有的东西都停下来，gc完了你们再执行。如果一个正在打字和MM聊天的用户突然被gc卡了一下，会不会觉得很不爽（当然没那么明显，但是还是肯定要考虑gc的时间的）。而这个主线程阻塞的时间既不会影响用户交互，干嘛不用来gc呢，至于其他线程，只要不是UI线程，gc阻碍一会又有什么关系呢。所以这个时间也可以给gc来考虑要不要gc。 到此摘取消息也讲的差不多了，我们之前已经讲过了处理消息的过程，消息机制的基本功能已经讲完了。 ###TODO：不过我还是有所保留的，对同步消息和异步消息这一块还没讲，然后对IdleHandler这一块也没有讲，还有就是Looper为什么要用ThreadLocal而不是用synchronized。因为要想讲明白这些，必须一层一层的往下走，先有一个基本的框架，然后再去看同步消息和异步消息其实也就是两个不同的消息类型而已，然后再取消息的过程有一点点区别，有一个时间分割栏的概念。主要还是为了让UI更流畅的显示的，平时开发基本用不着，在读View相关的源码的时候经常碰到，先有个这个印象。Looper用ThreadLocal也是基于让主线程在loop时不必因其他线程锁住Looper而等待（如果用synchronized，当其他线程用sendMessage时要拿到从Handler到Looper再到MessageQueue的引用，这是就要对Looper进行加锁。）（本篇完，下篇待续）","tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"Handler再一次回顾","date":"2016-12-17T11:19:57.000Z","path":"2016/12/17/Handler再一次回顾/","text":"只要是做过Android开发的，想必对Handler都不陌生。在我刚工作的时候就去看过Handler的源码，但当时局限于对多线程的理解并没有那么深刻，所以对Handler的理解也就仅仅停留在表面。现在有时间重看Handler源码，猛然发现：我擦，Handler这么简单，竟然好多面试都去问，好多人都是马马虎虎，一知半解。所以我想在这篇博客里，把Handler彻底讲透了，以后妈妈再也不用担心我对Handler的理解了。 其实很多人对Handler的不理解，关键还在于对线程的不理解，所以我决定先简单说下线程的相关的知识。我在这也不能跟你胡说，在Java里一切都是对象，我们先看下Java源码里线程类的注释： /** * A {@code Thread} is a concurrent unit of execution. It has its own call stack * for methods being invoked, their arguments and local variables. Each application * has at least one thread running when it is started, the main thread, in the main * {@link ThreadGroup}. The runtime keeps its own threads in the system thread * group. * * &lt;p&gt;There are two ways to execute code in a new thread. * You can either subclass {@code Thread} and overriding its {@link #run()} method, * or construct a new {@code Thread} and pass a {@link Runnable} to the constructor. * In either case, the {@link #start()} method must be called to actually execute * the new {@code Thread}. * * &lt;p&gt;Each {@code Thread} has an integer priority that affect how the thread is * scheduled by the OS. A new thread inherits the priority of its parent. * A thread&apos;s priority can be set using the {@link #setPriority(int)} method. */ 我在这也不逐行去翻译了，英语能看懂的就看看，按我的理解就是：线程就是一个执行序，有自己的执行栈。完了，就这么多。我知道这么说对于初学者者来说，肯定会在下面骂了，妈蛋，什么是执行序啊？先别急，把刀放下，咱慢慢说。我们写代码时，这个方法，那个对象，一堆乱七八糟的东西，要执行出一个确定的结果，肯定是要一个确定的顺序。包括多线程，只要逻辑上有先后顺序的信息，也一定要保证按确定的顺序来执行。 现在来想一下我们平时听了八百遍的多线程实现方式，实现 Runnable 接口，或者 new Thread() ，一个新的线程，我们不要忘了去调它的 start() 方法。这时才真正的启动了一个线程，去执行我们写在 run() 方法里的代码。其实从Android APP开发者的角度来讲，Thread的 run()就相当于Java框架给我们的一个执行代码的入口，让CPU来执行我们的代码（这么说当然是扯淡，但是你仅从APP开发者敲代码的角度去看，把编译，链接，虚拟机，操作系统全看成透明的，也就是这么个理）。 我们只要写好自己的代码，代码放进去 run() 的肚子里，然后按下开关(执行 start() 方法)，他就一直按我们写好的顺序调下去，直到所有代码执行结束。必须明白的一点是线程就是一个执行序，在Java里，他是一个类，我们要执行的代码要放到他的 run() 的肚子里面。然后调 start() 告诉 Java虚拟机，给我开一线程的执行环境，开启后来执行我写在 run() 里的代码。 有了这个认知以后我们再来看Thread的源码： public class Thread implements Runnable 这里看到的是Thread实现了Runnable接口，接着看下Runnable接口里面都定了哪些抽象方法： public interface Runnable { /** * Starts executing the active part of the class&apos; code. This method is * called when a thread is started that has been created with a class which * implements {@code Runnable}. */ public void run(); } 整个Runnable接口就这么可怜的一个 run() 方法。继续看Thread怎么实现的 run() 方法。 Runnable target; public void run() { if (target != null) { target.run(); } } 这里可以很清楚的看出来，无论是我们继承Runnable接口，还是直接new Thread实际上是没有区别的。都是最终要把需要执行的代码放到 Thread run() 的肚子里。然后调 start() 方法 public synchronized void start() { checkNotStarted(); hasBeenStarted = true; nativeCreate(this, stackSize, daemon); } start()这里就很显了 nativeCreate() 看名字就知道是调用C或C++去创建一个线程了，而创建线程以后呢，自然去调 run() 方法肚子里我们写的代码来执行了。 这时我们已经理解了我们Java层线程的意义。至于什么去stop线程啦，设置线程优先级，让线程去sleep啦，和start（）基本一样的，是交给Java框架（这里框架这个词可能不太好理解，容易误解为J2EE的框架。其实这样说是相当于把JDK当作一种框架来看，就像Android里用的FrameWork框架。）来处理的。不是我们调了这个方法就执行的，而是我们只能通过框架给我们写好的，暴露出来的接口，去跟框架交互，至于它背后是同步，异步，或者等两秒，或者怎样搞，这些只是线程具体实现上的事，跟我们理解这个线程是一个执行序没有一毛钱的关系。如果想对线程有更深入的了解，理解线程特性，可以去看一些JVM的书（比如，深入理解Java虚拟机），里面有具体的线程特性。 到了这里发现简单说下线程，似乎说了好多，并没有收住，还将继续说下去，其实还是想尽力说的明白些，因为从个人的经验来看，对线程的理解直接决定了对Handler的理解，懂线程的根本就不会不懂Handler，懂Handler不懂线程的，绕了几圈还是会晕。而且，我以前在学习Android的时候也被好多不负责任的博客折磨的死去活来。所以我最讨厌那种上来就甩你一脸定义，代码，专有名词，乱七八糟的东西，老子懂这些的话还看你在这逼逼？ 扯远了，继续说线程，刚刚说线程就是执行序，那么主线程呢？（在Android里一般主线程，UI线程，main线程都是在说一个玩意：主线程）。主线程既然是线程，它也是一个执行序，它也是由Java框架创建一个线程，然后执行写在它的 run() 方法肚子里的代码。现在要注意了，重点来了： 当我们点击桌面图标，桌面实际也是一个APP，上面放几个View，这些View的Image资源都是每个APP的图标，点击后就去执行的代码就是new一个进程，进程的资源什么乱七八糟的东西有一堆是根据你在APP的Manifest文件里面配置生成的。这一部分在这不讲，只需要知道，进程的必然要有一个主线程来执行APP里面写的代码吧。 在这里我们不去装逼的拿源码去讲什么第一个Activity的启动，还是按照上面的一个线程创建出要执行 run() 肚子里的代码。假如我们在里面写怎样去加载View，怎样去绘制View，然后展示出来，再然后呢，当View也绘制好了，展示出来了，界面都呈现出来了，这时代码执行序不就结束了么，按道理APP也就关掉了啊，不可能等在那让我们点击啊。其实这就是关键了，我们要想让这个主线程不执行结束，不死掉，应该还是很好解决的。比如直接在前面代码执行完以后，View显示出来了，让主线程去执行一个Whlie（true）的循环，这时不就万事大吉了么。View显示出来，一直显示着。 但是这样还有一个问题，就是主线程一直在while循环里跑，用户无法交互，主线程也无法继续执行这代码。其实这时候我们自己都能想到了，让主线程跑在while循环里，让他每次循环都去访问某个地方，看看有没有什么事要做，有就拿来做了再跑循环，没有就继续跑循环直到有事情做。其实Android整个UI机制就是这样的，装逼点说就是基于事件的机制，Windows其实也是这样的。 主线程跑在一个循环里面，而这个循环就是Looper的 loop() 方法。是时候让主角之一登场了： 说实话Looper的源码加注释真的写的相当清楚明白，而且代码量极少，我们直接看最前面关于Looper的注释： /** * Class used to run a message loop for a thread. Threads by default do * not have a message loop associated with them; to create one, call * {@link #prepare} in the thread that is to run the loop, and then * {@link #loop} to have it process messages until the loop is stopped. * * &lt;p&gt;Most interaction with a message loop is through the * {@link Handler} class. * * &lt;p&gt;This is a typical example of the implementation of a Looper thread, * using the separation of {@link #prepare} and {@link #loop} to create an * initial Handler to communicate with the Looper. * * &lt;pre&gt; * class LooperThread extends Thread { * public Handler mHandler; * * public void run() { * Looper.prepare(); * * mHandler = new Handler() { * public void handleMessage(Message msg) { * // process incoming messages here * } * }; * * Looper.loop(); * } * }&lt;/pre&gt; */ 最前面很显的写着：Looper这个类一般用于让线程去做一个消息的循环，线程里面本来是没有一个消息循环和线程相关联的。如果要创建一个有loop循环的线程，就要在线程的run方法里去调执行loop，让它在loop的过程中去处理消息。怎么样，和我前面讲的基本一样，我以宋吉吉的人格发誓，我之前没仔细看过这段注释，果然英雄所见略同。然后，注释又写了个例子，教你怎样写一个有Looper的线程。抬眼一瞅，这不就是在run方法的肚子里执行 Looer.loop() 么。。。 根据我们上面讲的线程的原理，即使不看这个 loop() 方法，先来猜一发，看看它里面会怎么写，无非是一个 while（ture) 循环，然后在里面每次有一个去消息，把消息里的代码执行的操作，好，上源码，接下来就是见证奇迹的时刻： public static void loop() { final Looper me = myLooper(); if (me == null) { throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;); } final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) { Message msg = queue.next(); // might block if (msg == null) { // No message indicates that the message queue is quitting. return; } // This must be in a local variable, in case a UI event sets the logger Printer logging = me.mLogging; if (logging != null) { logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; + msg.callback + &quot;: &quot; + msg.what); } msg.target.dispatchMessage(msg); if (logging != null) { logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback); } // Make sure that during the course of dispatching the // identity of the thread wasn&apos;t corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) { Log.wtf(TAG, &quot;Thread identity changed from 0x&quot; + Long.toHexString(ident) + &quot; to 0x&quot; + Long.toHexString(newIdent) + &quot; while dispatching to &quot; + msg.target.getClass().getName() + &quot; &quot; + msg.callback + &quot; what=&quot; + msg.what); } msg.recycleUnchecked(); } } 额额，loop() 方法是。。。日，竟然是个 for(;;) ,啪啪，这个不算打脸吧，和while(true) 一样嘛。继续看for循环里面的代码： Message msg = queue.next(); 这行就是从MessageQueue里面取一个Message，也就是从消息队列里取一个消息。如果消息是null，就丢弃掉，然后接下来自然不出我们所料要处理消息了： msg.target.dispatchMessage(msg); 这行自然就是处理消息了，这里面为什么这样写也是有技巧的，让我来解释一下（装一下逼）：因为线程在执行 loop() 的时候，并不知道要在每次循环去执行什么代码，所以在定义这个google在定义这个框架的时候，必须留一个接口，以你来写代码，框架来调用的形式定义。不看源码一切都是瞎逼逼，直接看源码，这个msg是一个Message对象，也就是一个消息，这没什么好说的。Message里有一个叫target的属性是Handler类型的： /*package*/ Handler target; 在Handler发送这个消息的时候会把Handler会把自己的引用放到这个消息的target属性里: public boolean sendMessageAtTime(Message msg, long uptimeMillis) { MessageQueue queue = mQueue; if (queue == null) { RuntimeException e = new RuntimeException( this + &quot; sendMessageAtTime() called with no mQueue&quot;); Log.w(&quot;Looper&quot;, e.getMessage(), e); return false; } return enqueueMessage(queue, msg, uptimeMillis); } private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) { msg.target = this; if (mAsynchronous) { msg.setAsynchronous(true); } return queue.enqueueMessage(msg, uptimeMillis); } 所以最终loop循环如果在消息队列里取到一个消息，就去执行发送这个消息的Handler的 dispatchMessage(msg) 方法，如果我们在去看这个方法，他一定会预留一个接口让我去写代码： public void dispatchMessage(Message msg) { if (msg.callback != null) { handleCallback(msg); } else { if (mCallback != null) { if (mCallback.handleMessage(msg)) { return; } } handleMessage(msg); } } 看到这最后调的这个方法我们应该就很熟悉了，我们平时new一个Handler一般都是这两种方式嘛： Handler handler = new Handler(new Handler.Callback() { @Override public boolean handleMessage(Message msg) { return false; } }); 或者 Handler handler = new Handler(){ @Override public void handleMessage(Message msg) { super.handleMessage(msg); } }; 这两种方法并没有什么鸟区别，一个用了接口，都是在 handleMessage(Message msg) 方法肚子里写我们要执行的代码。 再回到前面说的，线程在loop中循环，每次循环，没有消息就继续循环，取到消息就执行执行发送该消息的Handler的 dispatchMessage(Message msg) ，而这个方法最终执行的是我们填入代码的 handleMessage(Message msg) 方法。这样就实现了预留出接口，通过循环，让主线程一直取消息，然后我们通过发消息到MessageQueue，并写好收到消息后要执行的操作，让主线程来调，然后在循环过程中执行不同的代码，实现交互。 其实明白了主线程在loop循环的过程中是怎么工作的，Handler也就简单的一笔了，但是它里面还是有一些设计思想在里面。我准备多写几篇，具体到每行代码，把MessageQueue，Message，Handler的源码都拿过来晒晒，然后理解每一行代码的作用。虽然可能开发中使用不需要这么细致的理解，但是Android源码里面的设计思想还是有很多值得借鉴的地方，看着还是挺有意思的。 如果在这篇有没有看懂的地方也不用着急，因为后面会更细致的把整个涉及的知识讲完。 （本篇完，下篇待续）","tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"从梦想到梦醒","date":"2016-12-16T11:43:52.000Z","path":"2016/12/16/从梦想到梦醒/","text":"一直想弄自己的博客，却一直没有真正动手去做，一个是觉着自己平时连CSDN都没时间去总结，再弄个博客，写些乱七八糟的总有为赋新词强说愁的感觉。另一个是也确实被各种各样的事情占据着，静不下心，也腾不出手。最近工作初定，是时候给自己总结下了。（结果发现在github上弄一个自己的博客出奇的简单） 一个人从广州跑到帝都，考研胡闹准备了几个月，终究作罢，经历了拖拖拉拉的找工作的过程，总算一切安定下来了。在此算是梳理下自己的思绪，为以后做些规划，也算是走走停停，给自己留下点纪念。毕竟中二病一直病到现在没好，还是要留一个窗口，可以给自己总结，规划，无论是技术上的，生活上的，还是关于那飘忽不定的精神上的。 回头想想，感觉很多事情都说不上算是得还是失。在大三暑假的时候，我还对Android一无所知，然后稀里糊涂的学Java，当时的目的很单纯，就是想找个工作，对自己的定位就是：一无是处，一无所有，一无所知。后来稀里糊涂的就过了YY的面试，然后拿到一个相对还可以的offer，一个连View是什么都不知道的人拿到了YY Android开发工程师的Offer，就这样膨胀而又心虚的开始了浪完了自己的大四。当时以为的好事，现在回头看却觉得又是另外一回事。 由于自己的懵懂无知，对Android的认知仅限于如果我学完第一行代码一定很牛逼。工作并不像自己想象的那样，给你三个月准备时间来学习。上岗就开始了痛苦的挣扎，一个对Android一点都不懂的人上来就开始各种搞了，圆角图片拿到bitmap搜到个算法就直接开始计算，用SharedPreference存起来，代码中各种空指针Crash，不知道什么是Json。就这样经历了大概一个月，然后开始对Android一直半解。然后我们项目又是那种产品经理玩命催，开发疯狂加班的节奏，我的第一份工作，前三个月，公司打卡记录上几乎没有一天缺过我。当然也有周末去公司打游戏，心里其实异常压抑和苦闷的情况。 在YY的经历一直都是感觉特别压抑和苦闷的。后来回头想想，其实并不能怪任何人，也不是公司的问题（当时包括现在心里都还感激着在YY遇到的好多人，不细说了，放心里最好），主要还是自己的原因。以至于我每次看到需求，心情都是沉重的。总是看什么都先看自己哪些不会，哪些自己还没有掌握，心里暗暗发虚。每天就这样死撑着，依然没有什么进步。这样的日子可以想而知，以我狂放不羁（吃不了苦）的性格自然待不久了。 当一个人把自己都骗过了之后，就再也没有什么能阻挡他中二的节奏了。于是我开始了荒唐的考研。过程就不表了，说多了都是眼泪。 我似乎是一个什么事都需要反复咀嚼的人，当我离职以后，考研（修身养性）的过程中突然发现，原来那些把自己折磨的死去活来的东西竟然是那么简单。跳出每天死撑着上班的怪圈后自己突然成长了，对Android的理解也更深刻了。有好多东西莫名其妙回想起来的时候突然就明白了，期间自己也认真看了操作系统，一直觉的操作系统是最美，最吸引人的一个东西。以后有时间还要拿出来品味一番。 荒唐的考研没结束，就开始了拖拖拉拉的找工作，每天睡到下午，面试也不想去，书也不想看，每天就是觉得自己很累，其实啥也没做。 终于稀里糊涂找了一份工作，每天日子不再那么紧迫，上下班路上都能看看博客，工作时还能搞点新东西，每天过的还挺充实的。总觉得现在或许是自己上大学以来过的最踏实的一段日子，每天知道要干什么，虽然有时候很忙，有时候因为一个问题卡住，卡的很痛苦，但心里再也不会感到压抑或者感到没有信心。其实想明白了，当你自己看开的时候，没有任何人能拿你怎么样。每天有吃有喝，然后学自己想学的，看自己想看的，同时做好自己的本职工作，尽力为公司带来价值，这便足够。 其实一直想写点技术类的东西来着，比如最近做了OkHttp的封装，也装逼用了一把MVP，用了RxJava，对Glide了解了一些，但总觉的不想写别人写过的东西，别人没写过的，又没有大把的时间来研究，只能边学边看了。不过也算上路了，不再对什么技术产生高大上的畏惧心理，我觉得这便是最大的进步吧。。。（完）","tags":[{"name":"毒药","slug":"毒药","permalink":"http://yoursite.com/tags/毒药/"}]}]